<!-- CGNS Mid-Level Library - Grid Specification -->

<html>
<head>
<meta http-equiv="Content-Style-Type" content="text/css">
<title> CGNS Mid-Level Library - Grid Specification </title>
</head>

<h2>Grid Specification</h2>

<ul>
<li> <a href="#gridcoordinates">Zone Grid Coordinates</a>
     <ul>
     <li> <code><b>cg_grid_write</b></code> - Create a <code>GridCoordinates_t</code> node
     <li> <code><b>cg_ngrids</b></code> - Get number of <code>GridCoordinates_t</code> nodes
     <li> <code><b>cg_grid_read</b></code> - Get name of a <code>GridCoordinates_t</code> node
     <li> <code><b>cg_grid_bounding_box_read</b></code> - Get bounding box associated to a <code>GridCoordinates_t</code> node
     <li> <code><b>cg_grid_bounding_box_write</b></code> - Write bounding box associated to a <code>GridCoordinates_t</code> node
     <li> <code><b>cg_coord_write</b></code> - Write grid coordinates
     <li> <code><b>cg_coord_partial_write</b></code> - Write subset of grid coordinates
     <li> <code><b>cg_coord_general_write</b></code> - Write shaped array to a subset of grid coordinates
     <li> <code><b>cg_ncoords</b></code> - Get number of coordinate arrays
     <li> <code><b>cg_coord_info</b></code> - Get info about a coordinate array
     <li> <code><b>cg_coord_read</b></code> - Read grid coordinates
     <li> <code><b>cg_coord_general_read</b></code> - Read subset of grid coordinates to a shaped array
     </ul>
<li> <a href="#elements">Element Connectivity</a>
     <ul>
     <li> <code><b>cg_section_write</b></code> - Write fixed size element data
     <li> <code><b>cg_poly_section_write</b></code> - Write element data
     <li> <code><b>cg_section_general_write</b></code> - Write section data without element data
     <li> <code><b>cg_section_initialize</b></code> - Initialize element data for not fixed size elements
     <li> <code><b>cg_section_partial_write</b></code> - Write subset of element data
     <li> <code><b>cg_elements_partial_write</b></code> - Write element data for a fixed size element section
     <li> <code><b>cg_poly_elements_partial_write</b></code> - Write element data for an element section
     <li> <code><b>cg_elements_general_write</b></code> - Write element data for a fixed size element section
     <li> <code><b>cg_poly_elements_general_write</b></code> - Write element data for an element section
     <li> <code><b>cg_parent_data_write</b></code> - Write parent info for an element section
     <li> <code><b>cg_parent_data_partial_write</b></code> - Write subset of parent info for an element section
     <li> <code><b>cg_nsections</b></code> - Get number of element sections
     <li> <code><b>cg_section_read</b></code> - Get info for an element section
     <li> <code><b>cg_ElementDataSize</b></code> - Get size of element connectivity data array
     <li> <code><b>cg_ElementPartialSize</b></code> - Get size of element connectivity data array for partial read
     <li> <code><b>cg_elements_read</b></code> - Read fixed size element data
     <li> <code><b>cg_elements_partial_read</b></code> - Read subset of fixed size element data
     <li> <code><b>cg_elements_general_read</b></code> - Read subset of fixed size element data to a typed array
     <li> <code><b>cg_poly_elements_read</b></code> - Read element data
     <li> <code><b>cg_poly_elements_partial_read</b></code> - Read subset of element data
     <li> <code><b>cg_poly_elements_general_read</b></code> - Read subset of element data to typed arrays
     <li> <code><b>cg_parent_elements_general_read</b></code> - Read parent info for an element section
     <li> <code><b>cg_parent_elements_position_general_read</b></code> - Read parent position info for an element section
     <li> <code><b>cg_npe</b></code> - Get number of nodes for an element type
     </ul>
<li> <a href="#axisymmetry">Axisymmetry</a>
     <ul>
     <li> <code><b>cg_axisym_write</b></code> - Create axisymmetry data
     <li> <code><b>cg_axisym_read</b></code> - Read axisymmetry data
     </ul>
<li> <a href="#rotatingcoordinates">Rotating Coordinates</a>
     <ul>
     <li> <code><b>cg_rotating_write</b></code> - Create rotating coordinates data
     <li> <code><b>cg_rotating_read</b></code> - Read rotating coordinates data
     </ul>
</ul>

<a name="gridcoordinates"></a>
<h3>Zone Grid Coordinates</h3>

<i>Node</i>: <code>GridCoordinates_t</code>
             (<a href="../sids/gridflow.html#GridCoordinates">SIDS</a>,
              <a href="../filemap/nodes.html#GridCoordinates">File Mapping</a>)

<p>
<code>GridCoordinates_t</code> nodes are used to describe grids associated
with a particular zone.
The original grid must be described by a <code>GridCoordinates_t</code> node
named <code>GridCoordinates</code>.
Additional <code>GridCoordinates_t</code> nodes may be used, with user-defined
names, to store grids at multiple time steps or iterations.
In addition to the discussion of the <code>GridCoordinates_t</code> node
in the <a href="../sids/gridflow.html#GridCoordinates">SIDS</a> and
<a href="../filemap/nodes.html#GridCoordinates">File Mapping</a> manuals,
see the discussion of the
<a href="../sids/timedep.html#ZoneIterativeData"><code>ZoneIterativeData_t</code></a>
and <a href="../sids/timedep.html#ArbitraryGridMotion"><code>ArbitraryGridMotion_t</code></a>
nodes in the SIDS manual.

<br><br>
<table width=100% cellspacing=0 cellpadding=5 border rules=groups
       bgcolor="#f5f5f0">
<colgroup width=90%>
<colgroup>
<thead>
<tr><th align=left scope=col width=90%>Functions
    <th scope=col>Modes
<tbody>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_grid_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>char *GridCoordName</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>int *G</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_ngrids(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=out><i>int *ngrids</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_grid_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int G</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>char *GridCoordName</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_grid_bounding_box_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int G</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>DataType_t datatype</span>, <span class=in><i>void *bbox_array</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_grid_bounding_box_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int G</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>DataType_t datatype</span>, <span class=out><i>void *bbox_array</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tbody>
<tr><td nowrap>
        <code><b>call cg_grid_write_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>GridCoordName</span>, <span class=out><i>G</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_ngrids_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=out><i>ngrids</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_grid_read_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>G</span>, <span class=out><i>GridCoordName</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call <span class=cgf>cg_grid_bounding_box_write_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>G</span>, <span class=in>datatype</span>, <span class=in>bbox_array</span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call <span class=cgf>cg_grid_bounding_box_read_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>G</span>, <span class=in>datatype</span>, <span class=out>bbox_array</span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
</table>

<br>
<b><span class=in>Input</span>/<span class=out><i>Output</i></span></b>

<br><br>
<table cellspacing=0 cellpadding=0 noborder>
<tr valign=baseline><td><code>&nbsp;&nbsp;&nbsp;</code>
   <td><code>fn</code><td><code>&nbsp;&nbsp;</code>
   <td>CGNS file index number.
<tr valign=baseline><td>
   <td><code>B</code><td>
   <td>Base index number, where 1 &le; <code>B</code> &le; <code>nbases</code>.
<tr valign=baseline><td>
   <td><code>Z</code><td>
   <td>Zone index number, where 1 &le; <code>Z</code> &le; <code>nzones</code>.
<tr valign=baseline><td>
   <td><code>G</code><td>
   <td>Grid index number, where
       1 &le; <code>G</code> &le; <code>ngrids</code>.
<tr valign=baseline><td>
   <td><code>ngrids</code><td>
   <td>Number of <code>GridCoordinates_t</code> nodes for zone <code>Z</code>.
<tr valign=baseline><td>
   <td><code>GridCoordinateName</code><td>
   <td>Name of the <code>GridCoordinates_t</code> node.
       Note that the name "<code>GridCoordinates</code>" is reserved for the
       original grid and must be the first <code>GridCoordinates_t</code>
       node to be defined.
<tr valign=baseline><td>
   <td><code>datatype</code><td>
   <td>Data type of the bounding box array written to the file or read.
       Admissible data types for a coordinate bounding box are <code>RealSingle</code>
       and <code>RealDouble</code>.
<tr valign=baseline><td>
   <td><code>bbox_array</code><td>
   <td>Data Array with bounding box values.
<tr valign=baseline><td>
   <td><code>ier</code><td>
   <td>Error status.
</table>

<p>
The above functions are applicable to any <code>GridCoordinates_t</code> node.<br>
When reading a bounding box, if the information is missing from the file, the <code>bbox_array</code> will remain untouched, and a warning is emitted.<br>
The CGNS MLL relies on the user to compute the bounding box and ensure that the bounding box being stored is coherent with the coordinates under <code>GridCoordinates_t</code> node.


<a name="gridcoordinates_original"></a>
<br><br>
<table width=100% cellspacing=0 cellpadding=5 border rules=groups
       bgcolor="#f5f5f0">
<colgroup width=90%>
<colgroup>
<thead>
<tr><th align=left scope=col width=90%>Functions
    <th scope=col>Modes
<tbody>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_coord_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>DataType_t datatype</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>char *coordname</span>, <span class=in>void *coord_array</span>, <span class=out><i>int *C</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_coord_partial_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>DataType_t datatype</span>, <span class=in>char *coordname</span>, <span class=in>cgsize_t *range_min</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t *range_max</span>, <span class=in>void *coord_array</span>, <span class=out><i>int *C</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_coord_general_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>char *coordname</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>DataType_t datatype</span>, <span class=in>cgsize_t *range_min</span>, <span class=in>cgsize_t *range_max</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>DataType_t mem_datatype</span>, <span class=in>int mem_rank</span>, <span class=in>cgsize_t *mem_dimensions</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t *mem_range_min</span>, <span class=in>cgsize_t *mem_range_max</span>,</br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>void *coord_array</span>, <span class=out><i>int *C</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_ncoords(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=out><i>int *ncoords</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_coord_info(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int C</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>DataType_t *datatype</i></span>, <span class=out><i>char *coordname</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_coord_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>char *coordname</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>DataType_t mem_datatype</span>, <span class=in>cgsize_t *range_min</span>, <span class=in>cgsize_t *range_max</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>void *coord_array</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_coord_general_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>char *coordname</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t *range_min</span>, <span class=in>cgsize_t *range_max</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>DataType_t mem_datatype</span>, <span class=in>int mem_rank</span>, <span class=in>cgsize_t *mem_dimensions</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t *mem_range_min</span>, <span class=in>cgsize_t *mem_range_max</span>, <span class=out><i>void *coord_array</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tbody>
<tr><td nowrap>
        <code><b>call <span class=cgf>cg_coord_write_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>datatype</span>, <span class=in>coordname</span>, <span class=in>coord_array</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>C</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call <span class=cgf>cg_coord_partial_write_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>datatype</span>, <span class=in>coordname</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>range_min</span>, <span class=in>range_max</span>, <span class=in>coord_array</span>, <span class=out><i>C</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call <span class=cgf>cg_coord_general_write_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>coordname</span>, <span class=in>datatype</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>range_min</span>, <span class=in>range_max</span>, <span class=in>mem_datatype</span>, <span class=in>mem_rank</span>, <span class=in>mem_dimensions</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>mem_range_min</span>, <span class=in>mem_range_max</span>, <span class=in>coord_array</span>, <span class=out><i>C</i></span>, <span class=out><i>ier</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_ncoords_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=out><i>ncoords</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_coord_info_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>C</span>, <span class=out><i>datatype</i></span>, <span class=out><i>coordname</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call <span class=cgf>cg_coord_read_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>coordname</span>, <span class=in>mem_datatype</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>range_min</span>, <span class=in>range_max</span>, <span class=out><i>coord_array</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call <span class=cgf>cg_coord_general_read_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>coordname</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>range_min</span>, <span class=in>range_max</span>, <span class=in>mem_datatype</span>, <span class=in>mem_rank</span>, <span class=in>mem_dimensions</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>mem_range_min</span>, <span class=in>mem_range_max</span>, <span class=out><i>coord_array</i></span>, <span class=out><i>ier</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
</table>

<br>
<b><span class=in>Input</span>/<span class=out><i>Output</i></span></b>


<br><br>
<table cellspacing=0 cellpadding=0 noborder>
<tr valign=baseline><td><code>&nbsp;&nbsp;&nbsp;</code>
   <td><code>fn</code><td><code>&nbsp;&nbsp;</code>
   <td>CGNS file index number.
<tr valign=baseline><td>
   <td><code>B</code><td>
   <td>Base index number, where 1 &le; <code>B</code> &le; <code>nbases</code>.
<tr valign=baseline><td>
   <td><code>Z</code><td>
   <td>Zone index number, where 1 &le; <code>Z</code> &le; <code>nzones</code>.
<tr valign=baseline><td>
   <td><code>C</code><td>
   <td>Coordinate array index number, where
       1 &le; <code>C</code> &le; <code>ncoords</code>.
<tr valign=baseline><td>
   <td><code>ncoords</code><td>
   <td>Number of coordinate arrays for zone <code>Z</code>.
<tr valign=baseline><td>
   <td><code>datatype</code><td>
   <td>Data type of the coordinate array written to the file.
       Admissible data types for a coordinate array are <code>RealSingle</code>
       and <code>RealDouble</code>.
<tr valign=baseline><td>
   <td><code>coordname</code><td>
   <td>Name of the coordinate array.
       It is strongly advised to use the
       <a href="../sids/dataname.html#dataname_grid">SIDS nomenclature
       conventions</a> when naming the coordinate arrays to insure file
       compatibility.
<tr valign=baseline><td>
   <td><code>range_min</code><td>
   <td>Lower range index in file (eg., <code>imin, jmin, kmin</code>).
<tr valign=baseline><td>
   <td><code>range_max</code><td>
   <td>Upper range index in file (eg., <code>imax, jmax, kmax</code>).
<tr valign=baseline><td>
   <td><code>mem_datatype</code><td>
   <td>Data type of an array in memory.
       Admissible data types for a coordinate array are <code>RealSingle</code>
       and <code>RealDouble</code>..
<tr valign=baseline><td>
   <td><code>mem_rank</code><td>
   <td>Number of dimensions of array in memory.
<tr valign=baseline><td>
   <td><code>mem_dimensions</code><td>
   <td>Dimensions of array in memory.
<tr valign=baseline><td>
   <td><code>mem_range_min</code><td>
   <td>Lower range index in memory (eg., <code>imin, jmin, kmin</code>).
<tr valign=baseline><td>
   <td><code>mem_range_max</code><td>
   <td>Upper range index in memory (eg., <code>imax, jmax, kmax</code>).
<tr valign=baseline><td>
   <td><code>coord_array</code><td>
   <td>Array of coordinate values.
<tr valign=baseline><td>
   <td><code>ier</code><td>
   <td>Error status.
</table>

<p>
The above functions are applicable <em>only</em> to the 
<code>GridCoordinates_t</code> node named <code>GridCoordinates</code>, used
for the original grid in a zone.
Coordinates for additional <code>GridCoordinates_t</code> nodes in a zone
must be read and written using the
<a href="physical.html#dataarray"><code>cg_array_<i>xxx</i></code> functions</a>.

<p>
When writing, the function <code>cg_coord_write</code> will
automatically write the full range of coordinates (i.e., the entire
<code>coord_array</code>).
The functions <code>cg_coord_partial_write</code> and <code>cg_coord_general_write</code> may be used to write
only a subset of <code>coord_array</code>.
When using the partial write, any existing data as defined by
<code>range_min</code> and <code>range_max</code> will be overwritten by the new
values.
All other values will not be affected.

<p>
The function <code>cg_coord_read</code> returns the coordinate array
<code>coord_array</code>, for the range prescribed by <code>range_min</code> and
<code>range_max</code>.
The array is returned to the application in the data type requested in
<code>mem_datatype</code>.
This data type does not need to be the same as the one in which the
coordinates are stored in the file.
A coordinate array stored as double precision in the CGNS file can be
returned to the application as single precision, or vice versa.
The functions <code>cg_coord_general_read</code> and <code>cg_coord_general_write</code>
allow for type conversion when both reading from and writing to the file.

<p>
In Fortran, when using <code>cg_coord_read_f</code> to read 2D or 3D
coordinates, the extent of each dimension of <code>coord_array</code> must
be consistent with the requested range.
When reading a 1D solution, the declared size can be larger than the
requested range.
For example, for a 2D zone with 100 &times; 50 vertices, if
<code>range_min</code> and <code>range_max</code> are set to (11,11) and (20,20)
to read a subset of the coordinates, then <code>coord_array</code> must be
dimensioned (10,10).
If <code>coord_array</code> is declared larger (e.g., (100,50)) the
indices for the returned coordinates will be wrong.
These restrictions can be avoided by using <code>cg_coord_general_read_f</code> instead.

<p>
When using <code>cg_coord_general_write</code> and
<code>cg_coord_general_read</code>, the lower <em>core</em> vertices in the file
have index 1 for defining <code>range_min</code> and <code>range_max</code>; whereas
for the array in memory, defined by <code>mem_rank</code> and
<code>mem_dimensions</code>, the lower <em>array</em> vertices in memory have
index 1 for defining <code>mem_range_min</code> and <code>mem_range_max</code>.
The actual lower and upper bounds of the array in memory can be anything.
For example, to fully read a two-dimensional 6 &times 6 coordinate array with 1
rind plane on each side in the file to an 8 &times 8 array in memory
(<code>mem_rank</code> = 2 and <code>mem_dimensions</code> = (8,8)), set
<code>range_min</code> and <code>range_max</code> to (0,0) and (7,7), and set
<code>mem_range_min</code> and <code>mem_range_max</code> to (1,1) and (8,8).

<a name="elements"></a>
<h3>Element Connectivity</h3>

<i>Node</i>: <code>Elements_t</code>
             (<a href="../sids/gridflow.html#Elements">SIDS</a>,
              <a href="../filemap/nodes.html#Elements">File Mapping</a>)

<br><br>
<table width=100% cellspacing=0 cellpadding=5 border rules=groups
       bgcolor="#f5f5f0">
<colgroup width=90%>
<colgroup>
<thead>
<tr><th align=left scope=col width=90%>Functions
    <th scope=col>Modes
<tbody>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_section_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>char *ElementSectionName</span>, <span class=in>ElementType_t type</span>, <span class=in>cgsize_t start</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t end</span>, <span class=in>int nbndry</span>, <span class=in>cgsize_t *Elements</span>, <span class=out><i>int *S</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_poly_section_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>char *ElementSectionName</span>, <span class=in>ElementType_t type</span>, <span class=in>cgsize_t start</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t end</span>, <span class=in>int nbndry</span>, <span class=in>cgsize_t *Elements</span>, <span class=in>cgsize_t *ConnectOffset</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>int *S</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_section_general_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>char *ElementSectionName</span>, <span class=in>ElementType_t type</span>, <span class=in>DataType_t ElementDataType</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t start</span>, <span class=in>cgsize_t end</span>, <span class=in>cgsize_t ElementDataSize</span>, <span class=in>int nbndry</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>int *S</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_section_initialize(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_section_partial_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>char *ElementSectionName</span>, <span class=in>ElementType_t type</span>, <span class=in>cgsize_t start</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t end</span>, <span class=in>int nbndry</span>, <span class=out><i>int *S</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_elements_partial_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="in">cgsize_t start</span>, <span class="in">cgsize_t end</span>, <span class="in">cgsize_t *Elements</span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_poly_elements_partial_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="in">cgsize_t start</span>, <span class="in">cgsize_t end</span>, <span class="in">cgsize_t *Elements</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t *ConnectOffset</span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_elements_general_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="in">cgsize_t start</span>, <span class="in">cgsize_t end</span>, <span class="in">DataType_t mem_datatype</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="in">void *Elements</span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_poly_elements_general_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="in">cgsize_t start</span>, <span class="in">cgsize_t end</span>, <span class="in">DataType_t mem_datatype</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="in">void *Elements</span>, <span class=in>void *ConnectOffset</span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_parent_data_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t *ParentData</span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_parent_data_partial_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t start</span>, <span class=in>cgsize_t end</span>, <span class=in>cgsize_t *ParentData</span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_nsections(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=out><i>int *nsections</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_section_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>char *ElementSectionName</i></span>, <span class=out><i>ElementType_t *type</i></span>, <span class=out><i>cgsize_t *start</i></span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>cgsize_t *end</i></span>, <span class=out><i>int *nbndry</i></span>, <span class=out><i>int *parent_flag</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_ElementDataSize(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>cgsize_t *ElementDataSize</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_ElementPartialSize(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t start</span>, <span class=in>cgsize_t end</span>, <span class=out><i>cgsize_t *ElementDataSize</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_elements_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>, <span class=out><i>cgsize_t *Elements</i></span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>cgsize_t *ParentData</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_elements_partial_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t start</span>, <span class=in>cgsize_t end</span>, <span class=out><i>cgsize_t *Elements</i></span>, <span class=out><i>cgsize_t *ParentData</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_elements_general_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t start</span>, <span class=in>cgsize_t end</span>, <span class=in>DataType_t mem_datatype</span>, <span class=out><i>void *Elements</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_poly_elements_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>, <span class=out><i>cgsize_t *Elements</i></span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>cgsize_t *ConnectOffset</i></span>, <span class=out><i>cgsize_t *ParentData</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_poly_elements_partial_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t start</span>, <span class=in>cgsize_t end</span>, <span class=out><i>cgsize_t *Elements</i></span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>cgsize_t *ConnectOffset</i></span>, <span class=out><i>cgsize_t *ParentData</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_poly_elements_general_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t start</span>, <span class=in>cgsize_t end</span>, <span class=in>DataType_t *mem_datatype</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>void *Elements</i></span>, <span class=out><i>void *ConnectOffset</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_parent_elements_general_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t start</span>, <span class=in>cgsize_t end</span>, <span class=in>DataType_t *mem_datatype</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>void *ParentElement</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_parent_elements_position_general_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t start</span>, <span class=in>cgsize_t end</span>, <span class=in>DataType_t *mem_datatype</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>void *ParentFace</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_npe(<span class=in>ElementType_t type</span>, <span class=out><i>int *npe</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;w&nbsp;m</b></code>
<tbody>
<tr><td nowrap>
        <code><b>call <span class=cgf>cg_section_write_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>ElementSectionName</span>, <span class=in>type</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>start</span>, <span class=in>end</span>, <span class=in>nbndry</span>, <span class=in>Elements</span>, <span class=out><i>S</i></span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call <span class=cgf>cg_poly_section_write_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>ElementSectionName</span>, <span class=in>type</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>start</span>, <span class=in>end</span>, <span class=in>nbndry</span>, <span class=in>Elements</span>, <span class=in>ConnectOffset</span>, <span class=out><i>S</i></span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call <span class=cgf>cg_section_general_write_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>ElementSectionName</span>, <span class=in>type</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>ElementDataType</span>, <span class=in>start</span>, <span class=in>end</span>, <span class=in>ElementDataSize</span>, <span class=in>nbndry</span>, <span class=out><i>S</i></span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call <span class=cgf>cg_section_initialize_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>)</b><br>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_section_partial_write_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>ElementSectionName</span>, <span class=in>type</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>start</span>, <span class=in>end</span>, <span class=in>nbndry</span>, <span class=out><i>S</i></span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call <span class=cgf>cg_elements_partial_write_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class="in">start</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>end</span>, <span class=in>Elements</span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call <span class=cgf>cg_poly_elements_partial_write_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class="in">start</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>end</span>, <span class=in>Elements</span>, <span class=in>ConnectOffset</span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call <span class=cgf>cg_elements_general_write_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class="in">start</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>end</span>, <span class=in>mem_datatype</span>, <span class=in>Elements</span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call <span class=cgf>cg_poly_elements_general_write_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class="in">start</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>end</span>, <span class=in>mem_datatype</span>, <span class=in>Elements</span>, <span class=in>ConnectOffset</span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call <span class=cgf>cg_parent_data_write_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=in>ParentData</span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call <span class=cgf>cg_parent_data_partial_write_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=in>start</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>end</span>, <span class=in>ParentData</span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_nsections_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=out><i>nsections</i></span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_section_read_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=out><i>ElementSectionName</i></span>, <span class=out><i>type</i></span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>start</i></span>, <span class=out><i>end</i></span>, <span class=out><i>nbndry</i></span>, <span class=out><i>parent_flag</i></span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_ElementDataSize_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=out><i>ElementDataSize</i></span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_ElementPartialSize_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=in>start</span>, <span class=in>end</span>, <span class=out><i>ElementDataSize</i></span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call <span class=cgf>cg_elements_read_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=out><i>Elements</i></span>, <span class=out><i>ParentData</i></span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call <span class=cgf>cg_elements_partial_read_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=in>start</span>, <span class=in>end</span>, <span class=out><i>Elements</i></span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>ParentData</i></span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call <span class=cgf>cg_poly_elements_read_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=out><i>Elements</i></span>, <span class=out><i>ConnectOffset</i></span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>ParentData</i></span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call <span class=cgf>cg_poly_elements_partial_read_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=in>start</span>, <span class=in>end</span>, <span class=out><i>Elements</i></span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>ConnectOffset</i></span>, <span class=out><i>ParentData</i></span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
<code><b>call <span class=cgf>cg_elements_general_read_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=in>start</span>, <span class=in>end</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>mem_datatype</span>, <span class=out><i>Elements</i></span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
<code><b>call <span class=cgf>cg_poly_elements_general_read_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=in>start</span>, <span class=in>end</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>mem_datatype</span>, <span class=out><i>Elements</i></span>, <span class=out><i>ConnectOffset</i></span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
<code><b>call <span class=cgf>cg_parent_elements_general_read_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=in>start</span>, <span class=in>end</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>mem_datatype</span>, <span class=out><i>ParentElement</i></span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
<code><b>call <span class=cgf>cg_parent_elements_position_general_read_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=in>start</span>, <span class=in>end</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>mem_datatype</span>, <span class=out><i>ParentFace</i></span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_npe_f(<span class=in>type</span>, <span class=out><i>npe</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;w&nbsp;m</b></code>
</table>

<br>
<b><span class=in>Input</span>/<span class=out><i>Output</i></span></b>


<br><br>
<table cellspacing=0 cellpadding=0 noborder>
<tr valign=baseline><td><code>&nbsp;&nbsp;&nbsp;</code>
   <td><code>fn</code><td><code>&nbsp;&nbsp;</code>
   <td>CGNS file index number.
<tr valign=baseline><td>
   <td><code>B</code><td>
   <td>Base index number, where 1 &le; <code>B</code> &le; <code>nbases</code>.
<tr valign=baseline><td>
   <td><code>Z</code><td>
   <td>Zone index number, where 1 &le; <code>Z</code> &le; <code>nzones</code>.
<tr valign=baseline><td>
   <td><code>ElementSectionName</code><td>
   <td>Name of the <code>Elements_t</code> node.
<tr valign=baseline><td>
   <td><code>type</code><td>
   <td>Type of element.
       See the eligible types for <code>ElementType_t</code> in the
       <a href="general.html#typedefs">Typedefs</a> section.
<tr valign=baseline><td>
   <td><code>start</code><td>
   <td>Index of first element in the section.
<tr valign=baseline><td>
   <td><code>end</code><td>
   <td>Index of last element in the section.
<tr valign=baseline><td>
   <td><code>nbndry</code><td>
   <td>Index of last boundary element in the section.
       Set to zero if the elements are unsorted.
<tr valign=baseline><td>
   <td><code>nsections</code><td>
   <td>Number of element sections.
<tr valign=baseline><td>
   <td><code>S</code><td>
   <td>Element section index, where
       1 &le; <code>S</code> &le; <code>nsections</code>.
<tr valign=baseline><td>
   <td><code>parent_flag</code><td>
   <td>Flag indicating if the parent data are defined.
       If the parent data exist, <code>parent_flag</code> is set to 1;
       otherwise it is set to 0.
<tr valign=baseline><td>
   <td><code>ElementDataType</code><td>
   <td>Data type of an array. Admissible data types are <code>Integer</code> and <code>LongInteger</code>.
<tr valign=baseline><td>
   <td><code>ElementDataSize</code><td>
   <td>Number of element connectivity data values.
<tr valign=baseline><td>
   <td><code>Elements</code><td>
   <td>Element connectivity data. The element connectivity order is given in
       <a href="../sids/conv.html#unstructgrid">Element Numbering Conventions</a>.
<tr valign=baseline><td>
   <td><code>ConnectOffset</code><td>
   <td>Element connectivity offset data. This is required for <code>NGON_n</code>, <code>NFACE_n</code> and <code>MIXED</code> according to
       <a href="../sids/gridflow.html#Elements">Elements_t Structure Definition</a>.
<tr valign=baseline><td>
   <td><code>ParentData</code><td>
   <td>For boundary or interface elements, this array contains
       information on the cell(s) and cell face(s) sharing the element.
       If you do not need to read the <code>ParentData</code> when reading
       the <code>ElementData</code>, you may set the value to <code>NULL</code>.
<tr valign=baseline><td>
   <td><code>ParentElement</code><td>
   <td>For boundary or interface elements, this array contains
       information on the cell(s) sharing the element.
<tr valign=baseline><td>
   <td><code>ParentFace</code><td>
   <td>For boundary or interface elements, this array contains
       information on the cell face(s) sharing the element.
<tr valign=baseline><td>
   <td><code>mem_datatype</code><td>
   <td>Data type of an array in memory. Admissible data types are <code>Integer</code> and <code>LongInteger</code>.
<tr valign=baseline><td>
   <td><code>npe</code><td>
   <td>Number of nodes for an element of type <code>type</code>.
<tr valign=baseline><td>
   <td><code>ier</code><td>
   <td>Error status.
</table>

<p>
It is important to note that each element under a given <code>Zone_t</code> - including
all cells, faces, edges, boundary elements, etc. - must have a unique element index 
number. The numbering should be consecutive (i.e., no gaps).
This global numbering system insures that each and every element 
within a zone is uniquely identified by its number.

<p>
If the specified <code>Elements_t</code> node doesn't yet exist, it may be
created using either <code>cg_section_write</code> or
<code>cg_section_partial_write</code>.
<code>MIXED</code>, <code>NGON_n</code>, and <code>NFACE_n</code> element sets
 may be created using <code>cg_poly_section_write</code> or <code>cg_poly_section_partial_write</code>.
The function <code>cg_section_write</code> writes the full range as
indicated by <code>start</code> and <code>end</code> and supplied by the element
connectivity array <code>Elements</code>.
The <code>cg_section_partial_write</code> function will create the element section
data for the range <code>start</code> to <code>end</code> with the element data
initialized to 0. <code>cg_poly_section_write</code> and <code>cg_poly_section_partial_write</code>
 have a comparable behavior for <code>MIXED</code>, <code>NGON_n</code>, and <code>NFACE_n</code>. 
To add elements to the section, use <code>cg_elements_partial_write</code>
or <code>cg_poly_elements_partial_write</code>
and parent data (it it exists) using <code>cg_parent_data_partial_write</code>.
These functions will replace the data for the range
as indicated by <code>start</code> and <code>end</code> with the new values.
In most cases, the data is not duplicated in the mid-level library and
written directly from the user data to disk.The exception to this is in the case
of <code>MIXED</code>, <code>NGON_n</code>, and <code>NFACE_n</code> element sets. Even if 
the size of the element connectivity array can be known through <code>ConnectOffset</code>, the MLL
will keep a copy of the data in memory for the partial writes.

<p>
The functions <code>cg_elements_read</code> and <code>cg_poly_elements_read</code> returns all of the element
connectivity and parent data.
Specified subsets of the element connectivity and parent data may be
read using <code>cg_elements_partial_read</code> or <code>cg_poly_elements_partial_read</code> (<code>MIXED</code>, <code>NGON_n</code>, <code>NFACE_n</code>).

<p>
<code><b><font color="red">Note : cg_elements_read, cg_elements_partial_read, cg_section_write and cg_element_partial_write functions only work with fixed size elements.</font></b>

<a name="axisymmetry"></a>
<h3>Axisymmetry</h3>

<i>Node</i>: <code>Axisymmetry_t</code>
             (<a href="../sids/gridflow.html#Axisymmetry">SIDS</a>,
              <a href="../filemap/nodes.html#Axisymmetry">File Mapping</a>)

<br><br>
<table width=100% cellspacing=0 cellpadding=5 border rules=groups
       bgcolor="#f5f5f0">
<colgroup width=90%>
<colgroup>
<thead>
<tr><th align=left scope=col width=90%>Functions
    <th scope=col>Modes
<tbody>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_axisym_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>float *ReferencePoint</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>float *AxisVector</span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_axisym_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=out><i>float *ReferencePoint</i></span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>float *AxisVector</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tbody>
<tr><td nowrap>
        <code><b>call cg_axisym_write_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>ReferencePoint</span>, <span class=in>AxisVector</span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_axisym_read_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=out><i>ReferencePoint</i></span>, <span class=out><i>AxisVector</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
</table>

<br>
<b><span class=in>Input</span>/<span class=out><i>Output</i></span></b>


<br><br>
<table cellspacing=0 cellpadding=0 noborder>
<tr valign=baseline><td><code>&nbsp;&nbsp;&nbsp;</code>
   <td><code>fn</code><td><code>&nbsp;&nbsp;</code>
   <td>CGNS file index number.
<tr valign=baseline><td>
   <td><code>B</code><td>
   <td>Base index number, where 1 &le; <code>B</code> &le; <code>nbases</code>.
<tr valign=baseline><td>
   <td><code>ReferencePoint</code><td>
   <td>Origin used for defining the axis of rotation.
       (In Fortran, this is an array of Real*4 values.)
<tr valign=baseline><td>
   <td><code>AxisVector</code><td>
   <td>Direction cosines of the axis of rotation, through the reference
       point.
       (In Fortran, this is an array of Real*4 values.)
<tr valign=baseline><td>
   <td><code>ier</code><td>
   <td>Error status.
</table>

<p>
This node can only be used for a bi-dimensional model, i.e.,
<code>PhysicalDimension</code> must equal two.

<a name="rotatingcoordinates"></a>
<h3>Rotating Coordinates</h3>

<i>Node</i>: <code>RotatingCoordinates_t</code>
             (<a href="../sids/gridflow.html#RotatingCoordinates">SIDS</a>,
              <a href="../filemap/nodes.html#RotatingCoordinates">File Mapping</a>)

<br><br>
<table width=100% cellspacing=0 cellpadding=5 border rules=groups
       bgcolor="#f5f5f0">
<colgroup width=90%>
<colgroup>
<thead>
<tr><th align=left scope=col width=90%>Functions
    <th scope=col>Modes
<tbody>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_rotating_write(<span class=in>float *RotationRateVector</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>float *RotationCenter</span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_rotating_read(<span class=out><i>float *RotationRateVector</i></span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>float *RotationCenter</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tbody>
<tr><td nowrap>
        <code><b>call cg_rotating_write_f(<span class=in>RotationRateVector</span>, <span class=in>RotationCenter</span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_rotating_read_f(<span class=out><i>RotationRateVector</i></span>, <span class=out><i>RotationCenter</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
</table>

<br>
<b><span class=in>Input</span>/<span class=out><i>Output</i></span></b>


<br><br>
<table cellspacing=0 cellpadding=0 noborder>
<tr valign=baseline><td><code>&nbsp;&nbsp;&nbsp;</code>
   <td><code>RotationRateVector</code><td><code>&nbsp;&nbsp;</code>
   <td>Components of the angular velocity of the grid about the center
       of rotation.
       (In Fortran, this is an array of Real*4 values.)
<tr valign=baseline><td>
   <td><code>RotationCenter</code><td>
   <td>Coordinates of the center of rotation.
       (In Fortran, this is an array of Real*4 values.)
<tr valign=baseline><td>
   <td><code>ier</code><td>
   <td>Error status.
</table>

<p>
</body>
</html>
