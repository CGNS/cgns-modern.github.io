<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  
  <!-- Licensed under the Apache 2.0 License -->
  <link rel="stylesheet" type="text/css" href="../../_static/fonts/open-sans/stylesheet.css" />
  <!-- Licensed under the SIL Open Font License -->
  <link rel="stylesheet" type="text/css" href="../../_static/fonts/source-serif-pro/source-serif-pro.css" />
  <link rel="stylesheet" type="text/css" href="../../_static/css/bootstrap.min.css" />
  <link rel="stylesheet" type="text/css" href="../../_static/css/bootstrap-theme.min.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
    <title>Solution Data &#8212; CGNS Official Web Site</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/guzzle.css?v=ee5bbeb1" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/filemap.css?v=2c72f61b" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/math_override.css?v=97141bf4" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/midlevel.css?v=593b94c8" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=117e2fac"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="icon" href="../../_static/CGNS_empty.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Grid Connectivity" href="CGNS_MLL_connectivity.html" />
    <link rel="prev" title="Particle Specification" href="CGNS_MLL_particle.html" />
  
  <link rel="apple-touch-icon" href="../../_static/CGNS_empty.svg" />
  
   

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="CGNS_MLL_connectivity.html" title="Grid Connectivity"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="CGNS_MLL_particle.html" title="Particle Specification"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">CGNS Official Web Site</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../standard.html" >Standard Specification</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="CGNS_MLL.html" accesskey="U">CGNS/MLL - An API for C and Fortran applications</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Solution Data</a></li> 
      </ul>
    </div>
    <div class="container-wrapper">

      <div id="mobile-toggle">
        <a href="#"><span class="glyphicon glyphicon-align-justify" aria-hidden="true"></span></a>
      </div>
  <div id="left-column">
    <div class="sphinxsidebar">
<div class="sidebar-block">
  <div class="sidebar-wrapper">
    <div id="main-search">
      <form class="form-inline" action="../../search.html" method="GET" role="form">
        <div class="input-group">
          <input name="q" type="text" class="form-control" placeholder="Search...">
        </div>
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div>
      
    </div>
  </div>
        <div id="right-column">
          
          <div role="navigation" aria-label="breadcrumbs navigation">
            <ol class="breadcrumb">
              <li><a href="../../index.html">Docs</a></li>
              
                <li><a href="../../standard.html">Standard Specification</a></li>
              
                <li><a href="CGNS_MLL.html">CGNS/MLL - An API for C and Fortran applications</a></li>
              
              <li>Solution Data</li>
            </ol>
          </div>
          
          <div class="document clearer body">
            
  <section id="solution-data">
<span id="mllsolutiondata"></span><h1>Solution Data<a class="headerlink" href="#solution-data" title="Permalink to this heading">Â¶</a></h1>
<!-- CGNS Mid-Level Library - Solution Data -->

<html>
<head>
<meta http-equiv="Content-Style-Type" content="text/css">
<title> CGNS Mid-Level Library - Solution Data </title>
</head>

<h2>Solution Data</h2>

<ul>
<li> <a href="#flowsolution">Flow Solution</a>
     <ul>
     <li> <code><b>cg_sol_write</b></code> - Create and/or write to a <code>FlowSolution_t</code> node
     <li> <code><b>cg_nsols</b></code> - Get number of <code>FlowSolution_t</code> nodes
     <li> <code><b>cg_sol_info</b></code> - Get info about a <code>FlowSolution_t</code> node
     <li> <code><b>cg_sol_ptset_write</b></code> - Create a point set <code>FlowSolution_t</code> node
     <li> <code><b>cg_sol_ptset_info</b></code> - Get info about a point set <code>FlowSolution_t</code> node
     <li> <code><b>cg_sol_ptset_read</b></code> - Read a point set <code>FlowSolution_t</code> node
     <li> <code><b>cg_sol_size</b></code> - Get the dimensions of a <code>FlowSolution_t</code> node
     </ul>
<li> <a href="#flowsolution_array">Flow Solution Data</a>
     <ul>
     <li> <code><b>cg_field_write</b></code> - Write flow solution
     <li> <code><b>cg_field_partial_write</b></code> - Write subset of flow solution
     <li> <code><b>cg_field_general_write</b></code> - Write shaped array to a subset of flow solution
     <li> <code><b>cg_nfields</b></code> - Get number of flow solution arrays
     <li> <code><b>cg_field_info</b></code> - Get info about a flow solution array
     <li> <code><b>cg_field_read</b></code> - Read flow solution
     <li> <code><b>cg_field_general_read</b></code> - Read subset of flow solution to a shaped array
     </ul>
<li> <a href="#particlesolution">Particle Solution</a>
     <ul>
     <li> <code><b>cg_particle_sol_write</b></code> - Create and/or write to a <code>ParticleSolution_t</code> node
     <li> <code><b>cg_particle_nsols</b></code> - Get number of <code>ParticleSolution_t</code> nodes
     <li> <code><b>cg_particle_sol_info</b></code> - Get info about a <code>ParticleSolution_t</code> node
     <li> <code><b>cg_particle_sol_ptset_write</b></code> - Create a point set <code>ParticleSolution_t</code> node
     <li> <code><b>cg_particle_sol_ptset_info</b></code> - Get info about a point set <code>ParticleSolution_t</code> node
     <li> <code><b>cg_particle_sol_ptset_read</b></code> - Read a point set <code>ParticleSolution_t</code> node
     <li> <code><b>cg_particle_sol_size</b></code> - Get the dimensions of a <code>ParticleSolution_t</code> node
     </ul>
<li> <a href="#particlesolution_array">Particle Solution Data</a>
     <ul>
     <li> <code><b>cg_particle_field_write</b></code> - Write particle solution
     <li> <code><b>cg_particle_field_partial_write</b></code> - Write subset of particle solution
     <li> <code><b>cg_particle_field_general_write</b></code> - Write shaped array to a subset of particle solution
     <li> <code><b>cg_particle_nfields</b></code> - Get number of particle solution arrays
     <li> <code><b>cg_particle_field_info</b></code> - Get info about a particle solution array
     <li> <code><b>cg_particle_field_read</b></code> - Read particle solution
     <li> <code><b>cg_particle_field_general_read</b></code> - Read subset of particle solution to a shaped array
     </ul>   
<li> <a href="#discretedata">Discrete Data</a>
     <ul>
     <li> <code><b>cg_discrete_write</b></code> - Create a <code>DiscreteData_t</code> node
     <li> <code><b>cg_ndiscrete</b></code> - Get number of <code>DiscreteData_t</code> nodes
     <li> <code><b>cg_discrete_read</b></code> - Get name of a <code>DiscreteData_t</code> node
     <li> <code><b>cg_discrete_ptset_write</b></code> - Create a point set <code>DiscreteData_t</code> node
     <li> <code><b>cg_discrete_ptset_info</b></code> - Get info about a point set <code>DiscreteData_t</code> node
     <li> <code><b>cg_discrete_ptset_read</b></code> - Read a point set <code>DiscreteData_t</code> node
     <li> <code><b>cg_discrete_size</b></code> - Get the dimensions of a <code>DiscreteData_t</code> node
     </ul>
<li> <a href="#subregion">Zone Subregions</a>
     <ul>
     <li> <code><b>cg_nsubregs</b></code> - Get number of <code>ZoneSubRegion_t</code> nodes
     <li> <code><b>cg_subreg_info</b></code> - Get info about a <code>ZoneSubRegion_t</code> node
     <li> <code><b>cg_subreg_ptset_read</b></code> - Read point set data for a <code>ZoneSubRegion_t</code> node
     <li> <code><b>cg_subreg_bcname_read</b></code> - Read the <code>BC_t</code> node name for a <code>ZoneSubRegion_t</code> node
     <li> <code><b>cg_subreg_gcname_read</b></code> - Read the <code>GridConnectivity_t</code> node name for a <code>ZoneSubRegion_t</code> node
     <li> <code><b>cg_subreg_ptset_write</b></code> - Create a point set <code>ZoneSubRegion_t</code> node
     <li> <code><b>cg_subreg_bcname_write</b></code> - Create a <code>ZoneSubRegion_t</code> node that references a <code>BC_t</code> node
     <li> <code><b>cg_subreg_gcname_write</b></code> - Create a <code>ZoneSubRegion_t</code> node that references a <code>GridConnectivity_t</code> node
     </ul>
</ul>

<a name="flowsolution"></a>
<h3>Flow Solution</h3>

<i>Node</i>: <code>FlowSolution_t</code>
             (<a href="../sids/gridflow.html#FlowSolution">SIDS</a>,
              <a href="../filemap/nodes.html#FlowSolution">File Mapping</a>)

<br><br>
<table width=100% cellspacing=0 cellpadding=5 border rules=groups
       bgcolor="#f5f5f0">
<colgroup width=90%>
<colgroup>
<thead>
<tr><th align=left scope=col width=90%>Functions
    <th scope=col>Modes
<tbody>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_sol_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>char *solname</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>GridLocation_t location</span>, <span class=out><i>int *S</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_nsols(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=out><i>int *nsols</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_sol_info(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>, <span class=out><i>char *solname</i></span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>GridLocation_t *location</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_sol_ptset_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>const char *solname</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>GridLocation_t location</span>, <span class=in>PointSetType_t ptset_type</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t npnts</span>, <span class=in>const cgsize_t *pnts</span>, <span class=out><i>int *S</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_sol_ptset_info(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>PointSetType_t *ptset_type</i></span>, <span class=out><i>cgsize_t *npnts</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_sol_ptset_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>, <span class=out><i>cgsize_t *pnts</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_sol_size(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>, <span class=out><i>int *data_dim</i></span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>cgsize_t *dim_vals</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tbody>
<tr><td nowrap>
       <code><b>call cg_sol_write_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>solname</span>, <span class=in>location</span>, <span class=out><i>S</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_nsols_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=out><i>nsols</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_sol_info_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=out><i>solname</i></span>, <span class=out><i>location</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_sol_ptset_write_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>solname</span>, <span class=in>location</span>, <span class=in>ptset_type</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>npnts</span>, <span class=in>pnts</span>, <span class=out><i>S</i></span>, <span class=out><i>ier</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_sol_ptset_info_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=out><i>ptset_type</i></span>, <span class=out><i>npnts</i></span>, <span class=out><i>ier</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_sol_ptset_read_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=out><i>pnts</i></span>, <span class=out><i>ier</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_sol_size_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=out><i>data_dim</i></span>, <span class=out><i>dim_vals</i></span>, <span class=out><i>ier</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
</table>

<br>
<b><span class=in>Input</span>/<span class=out><i>Output</i></span></b>


<br><br>
<table cellspacing=0 cellpadding=0 noborder>
<tr valign=baseline><td><code>&nbsp;&nbsp;&nbsp;</code>
   <td><code>fn</code><td><code>&nbsp;&nbsp;</code>
   <td>CGNS file index number.
<tr valign=baseline><td>
   <td><code>B</code><td>
   <td>Base index number, where 1 &le; <code>B</code> &le; <code>nbases</code>.
<tr valign=baseline><td>
   <td><code>Z</code><td>
   <td>Zone index number, where 1 &le; <code>Z</code> &le; <code>nzones</code>.
<tr valign=baseline><td>
   <td><code>S</code><td>
   <td>Flow solution index number, where
       1 &le; <code>S</code> &le; <code>nsols</code>.
<tr valign=baseline><td>
   <td><code>nsols</code><td>
   <td>Number of flow solutions for zone <code>Z</code>.
<tr valign=baseline><td>
   <td><code>solname</code><td>
   <td>Name of the flow solution.
<tr valign=baseline><td>
   <td><code>location</code><td>
   <td>Grid location where the solution is recorded.
       The current admissible locations are <code>Vertex</code>,
       <code>CellCenter</code>, <code>IFaceCenter</code>, <code>JFaceCenter</code>,
       and <code>KFaceCenter</code>.
<tr valign=baseline><td>
   <td><code>ptset_type</code><td>
   <td>Type of point set defining the interface in the current solution;
       either <code>PointRange</code> or <code>PointList</code>.
<tr valign=baseline><td>
   <td><code>npnts</code><td>
   <td>Number of points defining the interface in the current solution.
       For a <code>ptset_type</code> of <code>PointRange</code>, <code>npnts</code>
       is always two.
       For a <code>ptset_type</code> of <code>PointList</code>, <code>npnts</code> is
       the number of points in the <code>PointList</code>.
<tr valign=baseline><td>
   <td><code>pnts</code><td>
   <td>Array of points defining the interface in the current solution.
<tr valign=baseline><td>
   <td><code>data_dim</code><td>
   <td>Number of dimensions defining the solution data. If a
       point set has been defined, this will be 1, otherwise
       this will be the current zone index dimension.</td>
<tr valign=baseline><td>
   <td><code>dim_vals</code><td>
   <td>The array of <code>data_dim</code> dimensions for the solution data.</td>
<tr valign=baseline><td>
   <td><code>ier</code><td>
   <td>Error status.
</table>

<p>
The above functions are used to create, and get information about,
<code>FlowSolution_t</code> nodes.

<p>
Solution data may be specified over the entire zone, as in previous
versions of the library, using <code>cg_sol_write</code> or over
a patch region of the zone using <code>cg_sol_ptset_write</code>.
The two are mutually exclusive. In the first case, the size of
the solution data is determined by the size of the zone, the
grid location, and rind data (if any) as in previous versions.
In the second case the solution data size is entirely determined
by the <code>PointList/PointRange</code> patch. In order to determine which of
the two forms in which the solution data was written, use
<code>cg_sol_ptset_info</code>. If the solution is over the entire
zone, <code>ptset_type</code> will be returned as <code>CG_Null</code>
and <code>npnts</code> as 0. Otherwise, <code>ptset_type</code> will
be either <code>PointList</code> or <code>PointRange</code>, and the
number of points will be returned in <code>npnts</code>.

<p>
To assist in determining the size of the solution data,
the function <code>cg_sol_size</code> has been added. For a solution
defined over the full zone, <code>data_dim</code> returns the index
dimension for the zone, and <code>dim_vals</code> specifies the
dimensions of the data, corrected for the grid location type
and rind data. If a point set patch has been specified,
<code>data_dim</code> will be 1 and <code>dim_vals</code> will contain
the total size of the patch.

<p>
Acceptable values of <code>GridLocation_t</code> are <code>Vertex</code>
and <code>CellCenter</code>. If the base cell dimension is 2 or
greater (surface or volume), then <code>EdgeCenter</code> is
also allowed. For 3 dimensional bases, <code>FaceCenter</code>, and
for structured zones, <code>IFaceCenter</code>, <code>JFaceCenter</code>
and <code>KFaceCenter</code>, are also acceptable.

<a name="flowsolution_array"></a>
<h3>Flow Solution Data</h3>

<table width=100% cellspacing=0 cellpadding=5 border rules=groups
       bgcolor="#f5f5f0">
<colgroup width=90%>
<colgroup>
<thead>
<tr><th align=left scope=col width=90%>Functions
    <th scope=col>Modes
<tbody>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_field_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>DataType_t datatype</span>, <span class=in>char *fieldname</span>, <span class=in>void *solution_array</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>int *F</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_field_partial_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>DataType_t datatype</span>, <span class=in>char *fieldname</span>, <span class=in>cgsize_t *range_min</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t *range_max</span>, <span class=in>void *solution_array</span>, <span class=out><i>int *F</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_field_general_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>, <span class=in>char *fieldname</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>DataType_t datatype</span>, <span class=in>cgsize_t *range_min</span>, <span class=in>cgsize_t *range_max</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>DataType_t mem_datatype</span>, <span class=in>int mem_rank</span>, <span class=in>cgsize_t *mem_dimensions</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t *mem_range_min</span>, <span class=in>cgsize_t *mem_range_max</span>,</br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>void *solution_array</span>, <span class=out><i>int *F</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_nfields(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>, <span class=out><i>int *nfields</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_field_info(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>, <span class=in>int F</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>DataType_t *datatype</i></span>, <span class=out><i>char *fieldname</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_field_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>, <span class=in>char *fieldname</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>DataType_t mem_datatype</span>, <span class=in>cgsize_t *range_min</span>, <span class=in>cgsize_t *range_max</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>void *solution_array</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_field_general_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>, <span class=in>char *fieldname</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t *range_min</span>, <span class=in>cgsize_t *range_max</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>DataType_t mem_datatype</span>, <span class=in>int mem_rank</span>, <span class=in>cgsize_t *mem_dimensions</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t *mem_range_min</span>, <span class=in>cgsize_t *mem_range_max</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>void *solution_array</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tbody>
<tr><td nowrap>
       <code><b>call <span class=cgf>cg_field_write_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=in>datatype</span>, <span class=in>fieldname</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>solution_array</span>, <span class=out><i>F</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
       <code><b>call <span class=cgf>cg_field_partial_write_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=in>datatype</span>, <span class=in>fieldname</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>range_min</span>, <span class=in>range_max</span>, <span class=in>solution_array</span>, <span class=out><i>F</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call <span class=cgf>cg_field_general_write_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=in>fieldname</span>, <span class=in>datatype</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>range_min</span>, <span class=in>range_max</span>, <span class=in>mem_datatype</span>, <span class=in>mem_rank</span>, <span class=in>mem_dimensions</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>mem_range_min</span>, <span class=in>mem_range_max</span>, <span class=in>solution_array</span>, <span class=out><i>F</i></span>, <span class=out><i>ier</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_nfields_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=out><i>nfields</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_field_info_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=in>F</span>, <span class=out><i>datatype</i></span>, <span class=out><i>fieldname</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call <span class=cgf>cg_field_read_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=in>fieldname</span>, <span class=in>mem_datatype</span>, <span class=in>range_min</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>range_max</span>, <span class=out><i>solution_array</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call <span class=cgf>cg_field_general_read_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=in>fieldname</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>range_min</span>, <span class=in>range_max</span>, <span class=in>mem_datatype</span>, <span class=in>mem_rank</span>, <span class=in>mem_dimensions</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>mem_range_min</span>, <span class=in>mem_range_max</span>, <span class=out><i>solution_array</i></span>, <span class=out><i>ier</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
</table>

<br>
<b><span class=in>Input</span>/<span class=out><i>Output</i></span></b>


<br><br>
<table cellspacing=0 cellpadding=0 noborder>
<tr valign=baseline><td><code>&nbsp;&nbsp;&nbsp;</code>
   <td><code>fn</code><td><code>&nbsp;&nbsp;</code>
   <td>CGNS file index number.
<tr valign=baseline><td>
   <td><code>B</code><td>
   <td>Base index number, where 1 &le; <code>B</code> &le; <code>nbases</code>.
<tr valign=baseline><td>
   <td><code>Z</code><td>
   <td>Zone index number, where 1 &le; <code>Z</code> &le; <code>nzones</code>.
<tr valign=baseline><td>
   <td><code>S</code><td>
   <td>Flow solution index number, where
       1 &le; <code>S</code> &le; <code>nsols</code>.
<tr valign=baseline><td>
   <td><code>F</code><td>
   <td>Solution array index number, where
       1 &le; <code>F</code> &le; <code>nfields</code>.
<tr valign=baseline><td>
   <td><code>nfields</code><td>
   <td>Number of data arrays in flow solution <code>S</code>.
<tr valign=baseline><td>
   <td><code>datatype</code><td>
   <td>Data type of the solution array written to the file.
       Admissible data types for a solution array are <code>Integer</code>,
       <code>LongInteger</code>, <code>RealSingle</code>, and <code>RealDouble</code>.
<tr valign=baseline><td>
   <td><code>fieldname</code><td>
   <td>Name of the solution array.
       It is strongly advised to use the
       <a href="../sids/dataname.html#dataname_flow">SIDS nomenclature
       conventions</a> when naming the solution arrays to insure file
       compatibility.
<tr valign=baseline><td>
   <td><code>range_min</code><td>
   <td>Lower range index in file (eg., <code>imin, jmin, kmin</code>).
<tr valign=baseline><td>
   <td><code>range_max</code><td>
   <td>Upper range index in file (eg., <code>imax, jmax, kmax</code>).
<tr valign=baseline><td>
   <td><code>mem_datatype</code><td>
   <td>Data type of an array in memory.
       Admissible data types for a solution array are <code>Integer</code>,
       <code>LongInteger</code>, <code>RealSingle</code>, and <code>RealDouble</code>.
<tr valign=baseline><td>
   <td><code>mem_rank</code><td>
   <td>Number of dimensions of array in memory.
<tr valign=baseline><td>
   <td><code>mem_dimensions</code><td>
   <td>Dimensions of array in memory.
<tr valign=baseline><td>
   <td><code>mem_range_min</code><td>
   <td>Lower range index in memory (eg., <code>imin, jmin, kmin</code>).
<tr valign=baseline><td>
   <td><code>mem_range_max</code><td>
   <td>Upper range index in memory (eg., <code>imax, jmax, kmax</code>).
<tr valign=baseline><td>
   <td><code>solution_array</code><td>
   <td>Array of solution values.
<tr valign=baseline><td>
   <td><code>ier</code><td>
   <td>Error status.
</table>

<p>
The above functions are used to read and write solution arrays stored
below a <code>FlowSolution_t</code> node.

<p>
When writing, the function <code>cg_field_write</code> will
automatically write the full range of the solution (i.e., the entire
<code>solution_array</code>).
The functions <code>cg_field_partial_write</code> and <code>cg_field_general_write</code> may be used to write
only a subset of <code>solution_array</code>.
When using the partial write, any existing data from <code>range_min</code>
to <code>range_max</code> will be overwritten by the new values.
All other values will not be affected.

<p>
The function <code>cg_field_read</code> returns the solution array
<code>fieldname</code>, for the range prescribed by <code>range_min</code> and
<code>range_max</code>.
The array is returned to the application in the data type requested in
<code>mem_datatype</code>.
This data type does not need to be the same as the one in which the data is
stored in the file.
A solution array stored as double precision in the CGNS file can be
returned to the application as single precision, or vice versa.
The functions <code>cg_field_general_read</code> and <code>cg_field_general_write</code>
allow for type conversion when both reading from and writing to the file.

<p>
In Fortran, when using <code>cg_field_read_f</code> to read a 2D or 3D
solution, the extent of each dimension of <code>solution_array</code> must
be consistent with the requested range.
When reading a 1D solution, the declared size can be larger than the
requested range.
For example, for a 2D zone with 100 &times; 50 vertices, if
<code>range_min</code> and <code>range_max</code> are set to (11,11) and (20,20)
to read a subset of the solution, then <code>solution_array</code> must be
dimensioned (10,10).
If <code>solution_array</code> is declared larger (e.g., (100,50)) the
indices for the returned array values will be wrong.
These restrictions can be avoided by using <code>cg_field_general_read_f</code> instead.

<p>
When using <code>cg_field_general_write</code> and
<code>cg_field_general_read</code>, the lower <em>core</em> locations in the file
have index 1 for defining <code>range_min</code> and <code>range_max</code>; whereas
for the array in memory, defined by <code>mem_rank</code> and
<code>mem_dimensions</code>, the lower <em>array</em> locations in memory have
index 1 for defining <code>mem_range_min</code> and <code>mem_range_max</code>.
The actual lower and upper bounds of the array in memory can be anything.
For example, to fully read a two-dimensional 6 &times 6 solution array with 1
rind plane on each side in the file to an 8 &times 8 array in memory
(<code>mem_rank</code> = 2 and <code>mem_dimensions</code> = (8,8)), set
<code>range_min</code> and <code>range_max</code> to (0,0) and (7,7), and set
<code>mem_range_min</code> and <code>mem_range_max</code> to (1,1) and (8,8).

<a name="particlesolution"></a>
<h3>Particle Solution</h3>

<i>Node</i>: <code>ParticleSolution_t</code>
             (<a href="../sids/particles.html#ParticleSolution">SIDS</a>,
              <a href="../filemap/nodes.html#ParticleSolution">File Mapping</a>)

<br><br>
<table width=100% cellspacing=0 cellpadding=5 border rules=groups
       bgcolor="#f5f5f0">
<colgroup width=90%>
<colgroup>
<thead>
<tr><th align=left scope=col width=90%>Functions
    <th scope=col>Modes
<tbody>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_particle_sol_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int P</span>, <span class=in>char *solname</span>, <span class=out><i>int *S</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_particle_nsols(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int P</span>, <span class=out><i>int *nsols</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_particle_sol_info(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int P</span>, <span class=in>int S</span>, <span class=out><i>char *solname</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_particle_sol_ptset_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int P</span>, <span class=in>const char *solname</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>PointSetType_t ptset_type</span>, <span class=in>cgsize_t npnts</span>, <span class=in>const cgsize_t *pnts</span>, <span class=out><i>int *S</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_particle_sol_ptset_info(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int P</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>PointSetType_t *ptset_type</i></span>, <span class=out><i>cgsize_t *npnts</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_particle_sol_ptset_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int P</span>, <span class=in>int S</span>, <span class=out><i>cgsize_t *pnts</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_particle_sol_size(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int P</span>, <span class=in>int S</span>, <span class=out><i>cgsize_t *size</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tbody>
<tr><td nowrap>
       <code><b>call cg_particle_sol_write_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>P</span>, <span class=in>solname</span>, <span class=out><i>S</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_particle_nsols_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>P</span>, <span class=out><i>nsols</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_particle_sol_info_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>P</span>, <span class=in>S</span>, <span class=out><i>solname</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_particle_sol_ptset_write_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>P</span>, <span class=in>solname</span>, <span class=in>ptset_type</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>npnts</span>, <span class=in>pnts</span>, <span class=out><i>S</i></span>, <span class=out><i>ier</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_particle_sol_ptset_info_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>P</span>, <span class=in>S</span>, <span class=out><i>ptset_type</i></span>, <span class=out><i>npnts</i></span>, <span class=out><i>ier</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_particle_sol_ptset_read_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>P</span>, <span class=in>S</span>, <span class=out><i>pnts</i></span>, <span class=out><i>ier</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_particle_sol_size_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=out><i>size</i></span>, <span class=out><i>ier</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
</table>

<br>
<b><span class=in>Input</span>/<span class=out><i>Output</i></span></b>


<br><br>
<table cellspacing=0 cellpadding=0 noborder>
<tr valign=baseline><td><code>&nbsp;&nbsp;&nbsp;</code>
   <td><code>fn</code><td><code>&nbsp;&nbsp;</code>
   <td>CGNS file index number.
<tr valign=baseline><td>
   <td><code>B</code><td>
   <td>Base index number, where 1 &le; <code>B</code> &le; <code>nbases</code>.
<tr valign=baseline><td>
   <td><code>P</code><td>
   <td>Particle index number, where 1 &le; <code>P</code> &le; <code>nparticlezones</code>.
<tr valign=baseline><td>
   <td><code>S</code><td>
   <td>Particle solution index number, where
       1 &le; <code>S</code> &le; <code>nsols</code>.
<tr valign=baseline><td>
   <td><code>nsols</code><td>
   <td>Number of particle solutions for particle <code>P</code>.
<tr valign=baseline><td>
   <td><code>solname</code><td>
   <td>Name of the particle solution.
<tr valign=baseline><td>
   <td><code>ptset_type</code><td>
   <td>Type of point set defining the interface in the current solution;
       either <code>PointRange</code> or <code>PointList</code>.
<tr valign=baseline><td>
   <td><code>npnts</code><td>
   <td>Number of points defining the interface in the current solution.
       For a <code>ptset_type</code> of <code>PointRange</code>, <code>npnts</code>
       is always two.
       For a <code>ptset_type</code> of <code>PointList</code>, <code>npnts</code> is
       the number of points in the <code>PointList</code>.
<tr valign=baseline><td>
   <td><code>pnts</code><td>
   <td>Array of points defining the interface in the current solution.
<tr valign=baseline><td>
   <td><code>size</code><td>
   <td>The size of the solution data.</td>
<tr valign=baseline><td>
   <td><code>ier</code><td>
   <td>Error status.
</table>

<p>
The above functions are used to create, and get information about,
<code>ParticleSolution_t</code> nodes.
        
<p>
Solution data may be specified over the all particles using <code>cg_particle_sol_write</code>
or over a subset of particles using <code>cg_particle_sol_ptset_write</code>.
The two are mutually exclusive. In the first case, the size of
the solution data is determined by the size of the <code>ParticleZone_t</code> node.
In the second case, the solution data size is entirely determined
by the <code>PointList/PointRange</code> patch. In order to determine which of
the two forms in which the solution data was written, use
<code>cg_particle_sol_ptset_info</code>. If the solution is over all particles,
<code>ptset_type</code> will be returned as <code>CG_Null</code>
and <code>npnts</code> as 0. Otherwise, <code>ptset_type</code> will
be either <code>PointList</code> or <code>PointRange</code>, and the
number of points will be returned in <code>npnts</code>.

<p>
To assist in determining the size of the solution data,
the function <code>cg_particle_sol_size</code> has been added.
The solution is implicitly assumed to be <code>Vertex</code> based wherein the vertex locations correspond to
the coordinates stored in the <code>ParcelCoordinates_t</code> node.

<a name="particlesolution_array"></a>
<h3>Particle Solution Data</h3>

<table width=100% cellspacing=0 cellpadding=5 border rules=groups
       bgcolor="#f5f5f0">
<colgroup width=90%>
<colgroup>
<thead>
<tr><th align=left scope=col width=90%>Functions
    <th scope=col>Modes
<tbody>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_particle_field_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int P</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>DataType_t datatype</span>, <span class=in>char *fieldname</span>, <span class=in>void *solution_array</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>int *F</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_particle_field_partial_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int P</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>DataType_t datatype</span>, <span class=in>char *fieldname</span>, <span class=in>cgsize_t *range_min</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t *range_max</span>, <span class=in>void *solution_array</span>, <span class=out><i>int *F</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_particle_field_general_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int P</span>, <span class=in>int S</span>, <span class=in>char *fieldname</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>DataType_t datatype</span>, <span class=in>cgsize_t *range_min</span>, <span class=in>cgsize_t *range_max</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>DataType_t mem_datatype</span>, <span class=in>cgsize_t *mem_dimensions</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t *mem_range_min</span>, <span class=in>cgsize_t *mem_range_max</span>,</br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>void *solution_array</span>, <span class=out><i>int *F</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_particle_nfields(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int P</span>, <span class=in>int S</span>, <span class=out><i>int *nfields</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_particle_field_info(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int P</span>, <span class=in>int S</span>, <span class=in>int F</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>DataType_t *datatype</i></span>, <span class=out><i>char *fieldname</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_particle_field_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int P</span>, <span class=in>int S</span>, <span class=in>char *fieldname</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>DataType_t mem_datatype</span>, <span class=in>cgsize_t *range_min</span>, <span class=in>cgsize_t *range_max</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>void *solution_array</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_particle_field_general_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int P</span>, <span class=in>int S</span>, <span class=in>char *fieldname</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t *range_min</span>, <span class=in>cgsize_t *range_max</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>DataType_t mem_datatype</span>, <span class=in>cgsize_t *mem_dimensions</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t *mem_range_min</span>, <span class=in>cgsize_t *mem_range_max</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>void *solution_array</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tbody>
<tr><td nowrap>
       <code><b>call <span class=cgf>cg_particle_field_write_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>P</span>, <span class=in>S</span>, <span class=in>datatype</span>, <span class=in>fieldname</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>solution_array</span>, <span class=out><i>F</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
       <code><b>call <span class=cgf>cg_particle_field_partial_write_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>P</span>, <span class=in>S</span>, <span class=in>datatype</span>, <span class=in>fieldname</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>range_min</span>, <span class=in>range_max</span>, <span class=in>solution_array</span>, <span class=out><i>F</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call <span class=cgf>cg_particle_field_general_write_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>P</span>, <span class=in>S</span>, <span class=in>fieldname</span>, <span class=in>datatype</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>range_min</span>, <span class=in>range_max</span>, <span class=in>mem_datatype</span>, <span class=in>mem_dimensions</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>mem_range_min</span>, <span class=in>mem_range_max</span>, <span class=in>solution_array</span>, <span class=out><i>F</i></span>, <span class=out><i>ier</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_particle_nfields_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>P</span>, <span class=in>S</span>, <span class=out><i>nfields</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_particle_field_info_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>P</span>, <span class=in>S</span>, <span class=in>F</span>, <span class=out><i>datatype</i></span>, <span class=out><i>fieldname</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call <span class=cgf>cg_particle_field_read_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>P</span>, <span class=in>S</span>, <span class=in>fieldname</span>, <span class=in>mem_datatype</span>, <span class=in>range_min</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>range_max</span>, <span class=out><i>solution_array</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call <span class=cgf>cg_particle_field_general_read_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>P</span>, <span class=in>S</span>, <span class=in>fieldname</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>range_min</span>, <span class=in>range_max</span>, <span class=in>mem_datatype</span>, <span class=in>mem_dimensions</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>mem_range_min</span>, <span class=in>mem_range_max</span>, <span class=out><i>solution_array</i></span>, <span class=out><i>ier</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
</table>

<br>
<b><span class=in>Input</span>/<span class=out><i>Output</i></span></b>


<br><br>
<table cellspacing=0 cellpadding=0 noborder>
<tr valign=baseline><td><code>&nbsp;&nbsp;&nbsp;</code>
   <td><code>fn</code><td><code>&nbsp;&nbsp;</code>
   <td>CGNS file index number.
<tr valign=baseline><td>
   <td><code>B</code><td>
   <td>Base index number, where 1 &le; <code>B</code> &le; <code>nbases</code>.
<tr valign=baseline><td>
   <td><code>P</code><td>
   <td>Particle index number, where 1 &le; <code>P</code> &le; <code>nparticlezones</code>.
<tr valign=baseline><td>
   <td><code>S</code><td>
   <td>Particle solution index number, where
       1 &le; <code>S</code> &le; <code>nsols</code>.
<tr valign=baseline><td>
   <td><code>F</code><td>
   <td>Solution array index number, where
       1 &le; <code>F</code> &le; <code>nfields</code>.
<tr valign=baseline><td>
   <td><code>nfields</code><td>
   <td>Number of data arrays in particle solution <code>S</code>.
<tr valign=baseline><td>
   <td><code>datatype</code><td>
   <td>Data type of the solution array written to the file.
       Admissible data types for a solution array are <code>Integer</code>,
       <code>LongInteger</code>, <code>RealSingle</code>, and <code>RealDouble</code>.
<tr valign=baseline><td>
   <td><code>fieldname</code><td>
   <td>Name of the solution array.
       It is strongly advised to use the
       <a href="../sids/dataname.html#dataname_flow"> SIDS nomenclature
       conventions</a> when naming the solution arrays to ensure file
       compatibility. Additionally, <a href="../sids/dataname.html#dataname_particles">particle specific SIDS nomenclature</a>
       can also be used
<tr valign=baseline><td>
   <td><code>range_min</code><td>
   <td>Lower range index in file.
<tr valign=baseline><td>
   <td><code>range_max</code><td>
   <td>Upper range index in file.
<tr valign=baseline><td>
   <td><code>mem_datatype</code><td>
   <td>Data type of an array in memory.
       Admissible data types for a solution array are <code>Integer</code>,
       <code>LongInteger</code>, <code>RealSingle</code>, and <code>RealDouble</code>.
<tr valign=baseline><td>
   <td><code>mem_dimensions</code><td>
   <td>Dimensions of array in memory.
<tr valign=baseline><td>
   <td><code>mem_range_min</code><td>
   <td>Lower range index in memory.
<tr valign=baseline><td>
   <td><code>mem_range_max</code><td>
   <td>Upper range index in memory.
<tr valign=baseline><td>
   <td><code>solution_array</code><td>
   <td>Array of solution values.
<tr valign=baseline><td>
   <td><code>ier</code><td>
   <td>Error status.
</table>

<p>
The above functions are used to read and write solution arrays stored
below a <code>ParticleSolution_t</code> node.

<p>
When writing, the function <code>cg_particle_field_write</code> will
automatically write the full range of the solution (i.e., the entire
<code>solution_array</code>).
The functions <code>cg_particle_field_partial_write</code> and <code>cg_particle_field_general_write</code> may be used
to write
only a subset of <code>solution_array</code>.
When using the partial write, any existing data from <code>range_min</code>
to <code>range_max</code> will be overwritten by the new values.
All other values will not be affected.

<p>
The function <code>cg_particle_field_read</code> returns the solution array
<code>fieldname</code>, for the range prescribed by <code>range_min</code> and
<code>range_max</code>.
The array is returned to the application in the data type requested in
<code>mem_datatype</code>.
This data type does not need to be the same as the one in which the data is
stored in the file.
A solution array stored as double precision in the CGNS file can be
returned to the application as single precision, or vice versa.
The functions <code>cg_particle_field_general_read</code> and <code>cg_particle_field_general_write</code>
allow for type conversion when both reading from and writing to the file.

<p>
When using <code>cg_particle_field_general_write</code> and
<code>cg_particle_field_general_read</code>, the lower <em>core</em> locations in the file
have index 1 for defining <code>range_min</code> and <code>range_max</code>; whereas
for the array in memory, the lower <em>array</em> locations in memory have
index 1 for defining <code>mem_range_min</code> and <code>mem_range_max</code>.
The actual lower and upper bounds of the array in memory can be anything.
        

<a name="discretedata"></a>
<h3>Discrete Data</h3>

<i>Node</i>: <code>DiscreteData_t</code>
             (<a href="../sids/misc.html#DiscreteData">SIDS</a>,
              <a href="../filemap/nodes.html#DiscreteData">File Mapping</a>)

<br><br>
<table width=100% cellspacing=0 cellpadding=5 border rules=groups
       bgcolor="#f5f5f0">
<colgroup width=90%>
<colgroup>
<thead>
<tr><th align=left scope=col width=90%>Functions
    <th scope=col>Modes
<tbody>
<tr><td nowrap>
       <code><b><span class=out><i>ier</i></span> = cg_discrete_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>char *DiscreteName</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>int *D</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_ndiscrete(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=out><i>int *ndiscrete</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_discrete_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int D</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>char *DiscreteName</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_discrete_ptset_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>const char *DiscreteName</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>GridLocation_t location</span>, <span class=in>PointSetType_t ptset_type</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t npnts</span>, <span class=in>const cgsize_t *pnts</span>, <span class=out><i>int *D</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_discrete_ptset_info(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int D</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>PointSetType_t *ptset_type</i></span>, <span class=out><i>cgsize_t *npnts</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_discrete_ptset_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int D</span>, <span class=out><i>cgsize_t *pnts</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_discrete_size(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int D</span>, <span class=out><i>int *data_dim</i></span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>cgsize_t *dim_vals</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tbody>
<tr><td nowrap>
       <code><b>call cg_discrete_write_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>DiscreteName</span>, <span class=out><i>D</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_ndiscrete_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=out><i>ndiscrete</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_discrete_read_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>D</span>, <span class=out><i>DiscreteName</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_discrete_ptset_write_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>DiscreteName</span>, <span class=in>location</span>, <span class=in>ptset_type</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>npnts</span>, <span class=in>pnts</span>, <span class=out><i>D</i></span>, <span class=out><i>ier</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_discrete_ptset_info_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>D</span>, <span class=out><i>ptset_type</i></span>, <span class=out><i>npnts</i></span>, <span class=out><i>ier</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_discrete_ptset_read_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>D</span>, <span class=out><i>pnts</i></span>, <span class=out><i>ier</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_discrete_size_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>D</span>, <span class=out><i>data_dim</i></span>, <span class=out><i>dim_vals</i></span>, <span class=out><i>ier</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
</table>

<br>
<b><span class=in>Input</span>/<span class=out><i>Output</i></span></b>


<br><br>
<table cellspacing=0 cellpadding=0 noborder>
<tr valign=baseline><td><code>&nbsp;&nbsp;&nbsp;</code>
   <td><code>fn</code><td><code>&nbsp;&nbsp;</code>
   <td>CGNS file index number.
<tr valign=baseline><td>
   <td><code>B</code><td>
   <td>Base index number, where 1 &le; <code>B</code> &le; <code>nbases</code>.
<tr valign=baseline><td>
   <td><code>Z</code><td>
   <td>Zone index number, where 1 &le; <code>Z</code> &le; <code>nzones</code>.
<tr valign=baseline><td>
   <td><code>D</code><td>
   <td>Discrete data index number, where
       1 &le; <code>D</code> &le; <code>ndiscrete</code>.
<tr valign=baseline><td>
   <td><code>ndiscrete</code><td>
   <td>Number of <code>DiscreteData_t</code> data structures under zone <code>Z</code>.
<tr valign=baseline><td>
   <td><code>DiscreteName</code><td>
   <td>Name of <code>DiscreteData_t</code> data structure.
<tr valign=baseline><td>
   <td><code>location</code><td>
   <td>Grid location where the discrete data is recorded.
       The current admissible locations are <code>Vertex</code>,
       <code>CellCenter</code>, <code>IFaceCenter</code>, <code>JFaceCenter</code>,
       and <code>KFaceCenter</code>.
<tr valign=baseline><td>
   <td><code>ptset_type</code><td>
   <td>Type of point set defining the interface for the discrete data;
       either <code>PointRange</code> or <code>PointList</code>.
<tr valign=baseline><td>
   <td><code>npnts</code><td>
   <td>Number of points defining the interface for the discrete data.
       For a <code>ptset_type</code> of <code>PointRange</code>, <code>npnts</code>
       is always two.
       For a <code>ptset_type</code> of <code>PointList</code>, <code>npnts</code> is
       the number of points in the list.
<tr valign=baseline><td>
   <td><code>pnts</code><td>
   <td>Array of points defining the interface for the discrete data.
<tr valign=baseline><td>
   <td><code>data_dim</code><td>
   <td>Number of dimensions defining the discrete data. If a
       point set has been defined, this will be 1, otherwise
       this will be the current zone index dimension.</td>
<tr valign=baseline><td>
   <td><code>dim_vals</code><td>
   <td>The array of <code>data_dim</code> dimensions for the discrete data.</td>
<tr valign=baseline><td>
   <td><code>ier</code><td>
   <td>Error status.
</table>

<p>
<code>DiscreteData_t</code> nodes are intended for the storage of fields
of data not usually identified as part of the flow solution, such as
fluxes or equation residuals.

<p>
The description for these functions is similar to the
<a href="#flowsolution"><code>FlowSolution_t</code></a> node as described above.
To read and write the discrete data, use
<a href="navigating.html#goto"><code>cg_goto</code></a> to access the
<code>DiscreteData_t</code> node, then
<a href="physical.html#dataarray"><code>cg_array_read</code></a> and
<a href="physical.html#dataarray"><code>cg_array_write</code></a>.
The dimensions provided to the array-write family of functions must match the dimensions specified by the <code>Zone_t</code> and DiscreteData_t</code> nodes.  Use <a href="location.html#gridlocation"><code>cg_gridlocation_write</code></a> and
<a href="location.html#rind"><code>cg_rind_write</code></a> under the <code>DiscreteData_t</code> node, as required.

<a name="subregion"></a>
<h3>Zone Subregions</h3>

<i>Node</i>: <code>ZoneSubRegion_t</code>
             (<a href="../sids/gridflow.html#ZoneSubRegion">SIDS</a>,
              <a href="../filemap/nodes.html#ZoneSubRegion">File Mapping</a>)

<br><br>
<table width=100% cellspacing=0 cellpadding=5 border rules=groups
       bgcolor="#f5f5f0">
<colgroup width=90%>
<colgroup>
<thead>
<tr><th align=left scope=col width=90%>Functions
    <th scope=col>Modes
<tbody>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_nsubregs(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=out><i>int *nsubregs</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_subreg_info(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>, <span class=out><i>char *regname</i></span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>int *dimension</i></span>, <span class=out><i>GridLocation_t *location</i></span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>PointSetType_t *ptset_type</i></span>, <span class=out><i>cgsize_t *npnts</i></span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>int *bcname_len</i></span>, <span class=out><i>int *gcname_len</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_subreg_ptset_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>, <span class=out><i>cgsize_t *pnts</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_subreg_bcname_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>, <span class=out><i>char *bcname</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_subreg_gcname_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>, <span class=out><i>char *gcname</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_subreg_ptset_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>const char *regname</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>int dimension</span>, <span class=in>GridLocation_t location</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>PointSetType_t ptset_type</span>, <span class=in>cgsize_t npnts</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>const cgsize_t *pnts</span>, <span class=out><i>int *S</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_subreg_bcname_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>const char *regname</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>int dimension</span>, <span class=in>const char *bcname</span>, <span class=out><i>int *S</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b><span class=out><i>ier</i></span> = cg_subreg_gcname_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>const char *regname</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>int dimension</span>, <span class=in>const char *gcname</span>, <span class=out><i>int *S</i></span>);</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tbody>
<tr><td nowrap>
        <code><b>call cg_nsubregs_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=out><i>nsubregs</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_subreg_info_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=out><i>regname</i></span>, <span class=out><i>dimension</i></span>, <span class=out><i>location</i></span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>ptset_type</i></span>, <span class=out><i>npnts</i></span>, <span class=out><i>bcname_len</i></span>, <span class=out><i>gcname_len</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_subreg_ptset_read_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=out><i>pnts</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_subreg_bcname_read_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=out><i>bcname</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_subreg_gcname_read_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=out><i>gcname</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>r&nbsp;-&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_subreg_ptset_write_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>regname</span>,  <span class=in>dimension</span>, <span class=in>location</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>ptset_type</span>, <span class=in>npnts</span>, <span class=in>pnts</span>, <span class=out><i>S</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_subreg_bcname_write_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>regname</span>, <span class=in>dimension</span>, <span class=in>bcname</span>, <span class=out><i>S</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
<tr><td nowrap>
        <code><b>call cg_subreg_gcname_write_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>regname</span>, <span class=in>dimension</span>, <span class=in>gcname</span>, <span class=out><i>S</i></span>, <span class=out><i>ier</i></span>)</b></code>
    <td align=center valign=baseline>
        <code><b>-&nbsp;w&nbsp;m</b></code>
</table>

<br>
<b><span class=in>Input</span>/<span class=out><i>Output</i></span></b>


<br><br>
<table cellspacing=0 cellpadding=0 noborder>
<tr valign=baseline><td><code>&nbsp;&nbsp;&nbsp;</code>
   <td><code>fn</code><td><code>&nbsp;&nbsp;</code>
   <td>CGNS file index number.
<tr valign=baseline><td>
   <td><code>B</code><td>
   <td>Base index number, where 1 &le; <code>B</code> &le; <code>nbases</code>.
<tr valign=baseline><td>
   <td><code>Z</code><td>
   <td>Zone index number, where 1 &le; <code>Z</code> &le; <code>nzones</code>.
<tr valign=baseline><td>
   <td><code>S</code><td>
   <td>ZoneSubRegion index number, where 1 &le; <code>S</code> &le; <code>nsubregs</code>.
<tr valign=baseline><td>
   <td><code>nsubregs</code><td>
   <td>Number of <code>ZoneSubRegion_t</code> nodes under Zone <code>Z</code>.
<tr valign=baseline><td>
   <td><code>regname</code><td>
   <td>Name of the <zz>ZoneSubRegion_t</code> node,</td>
<tr valign=baseline><td>
   <td><code>dimension</code><td>
   <td>Dimensionality of the subregion, 1 for lines, 2 for faces,
       3 for volumes,</td>
<tr valign=baseline><td>
   <td><code>location</code><td>
   <td>Grid location used in the definition of the point set.
       The currently admissible locations are <code>Vertex</code> and
       <code>CellCenter</code>.
<tr valign=baseline><td>
   <td><code>ptset_type</code><td>
   <td>Type of point set defining the interface for the subregion data;
       either <code>PointRange</code> or <code>PointList</code>.
<tr valign=baseline><td>
   <td><code>npnts</code><td>
   <td>Number of points defining the interface for the subregion data.
       For a <code>ptset_type</code> of <code>PointRange</code>, <code>npnts</code>
       is always two.
       For a <code>ptset_type</code> of <code>PointList</code>, <code>npnts</code> is
       the number of points in the <code>PointList</code>.
<tr valign=baseline><td>
   <td><code>pnts</code><td>
   <td>Array of points defining the interface  for the subregion data.
<tr valign=baseline><td>
   <td><code>bcname</code><td>
   <td>The name of a <code>BC_t</code> node which defines the subregion.</td>
<tr valign=baseline><td>
   <td><code>gcname</code><td>
   <td>The name of a <code>GridConnectivity_t</code> or
       <code>GridConnectivity1to1_t</code> node which defines the subregion.</td>
<tr valign=baseline><td>
   <td><code>bcname_len</code><td>
   <td>String length of <code>bcname</code>.</td>
<tr valign=baseline><td>
   <td><code>gcname_len</code><td>
   <td>String length of <code>gcname</code>.</td>
<tr valign=baseline><td>
   <td><code>ier</code><td>
   <td>Error status.
</table>

<p>
These functions allow for the specification of Zone subregions. The
subregion may be specified as either the name of an existing
<code>BC_t</code> node (<code>cg_subreg_bcname_write</code>), an
existing <code>GridConnectivity_t</code> or <code>GridConnectivity1to1_t</code>
node (<code>cg_subreg_gcname_write</code>), or as a <code>PointSet/PointRange</code>
(<code>cg_subreg_ptset_write</code>). These specifications are mutually
exclusive. To determine the type of the subregion, use
<code>cg_subreg_info</code>. If the subregion is a point set,
then <code>ptset_type</code> will indicate the point set type (either
<code>PointList</code> or <code>PointRange</code>) and <code>npts</code> will be
set to the number of points to define the region. Otherwise,
<code>ptset_type</code> will be set to <code>CG_Null</code> and
<code>npnts</code> will be 0. In this case, one of <code>bcname_len</code>
or <code>gcname_len</code> will be non-zero, indicating whether the
ZoneSubRegion references a <code>BC_t</code> node
(<code>bcname_len</code> non-zero) or
<code>GridConnectivity_t</code> node (<code>gcname_len</code> non-zero).

<p>

</body>
</html>
</section>


          </div>
            
  <div class="footer-relations">
    
      <div class="pull-left">
        <a class="btn btn-default" href="CGNS_MLL_particle.html" title="previous chapter (use the left arrow)">Particle Specification</a>
      </div>
    
      <div class="pull-right">
        <a class="btn btn-default" href="CGNS_MLL_connectivity.html" title="next chapter (use the right arrow)">Grid Connectivity</a>
      </div>
    </div>
    <div class="clearer"></div>
  
        </div>
        <div class="clearfix"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="CGNS_MLL_connectivity.html" title="Grid Connectivity"
             >next</a> |</li>
        <li class="right" >
          <a href="CGNS_MLL_particle.html" title="Particle Specification"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">CGNS Official Web Site</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../standard.html" >Standard Specification</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="CGNS_MLL.html" >CGNS/MLL - An API for C and Fortran applications</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Solution Data</a></li> 
      </ul>
    </div>
<script type="text/javascript">
  $("#mobile-toggle a").click(function () {
    $("#left-column").toggle();
  });
</script>
<script type="text/javascript" src="../../_static/js/bootstrap.js"></script>
  <div class="footer">
    &copy; Copyright 1991-2020, CGNS Steering Commmittee. Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
  </div>
  </body>
</html>