
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  
  <!-- Licensed under the Apache 2.0 License -->
  <link rel="stylesheet" type="text/css" href="../../_static/fonts/open-sans/stylesheet.css" />
  <!-- Licensed under the SIL Open Font License -->
  <link rel="stylesheet" type="text/css" href="../../_static/fonts/source-serif-pro/source-serif-pro.css" />
  <link rel="stylesheet" type="text/css" href="../../_static/css/bootstrap.min.css" />
  <link rel="stylesheet" type="text/css" href="../../_static/css/bootstrap-theme.min.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
    <title>Grid Specification &#8212; CGNS Official Web Site</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/guzzle.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/filemap.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/math_override.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/css/midlevel.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/CGNS_empty.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Solution Data" href="CGNS_MLL_solution.html" />
    <link rel="prev" title="Auxiliary Data" href="CGNS_MLL_auxiliary.html" />
  
  <link rel="apple-touch-icon" href="../../_static/CGNS_empty.svg" />
  
   

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="CGNS_MLL_solution.html" title="Solution Data"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="CGNS_MLL_auxiliary.html" title="Auxiliary Data"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">CGNS Official Web Site</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../standard.html" >Standard Specification</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="CGNS_MLL.html" accesskey="U">CGNS/MLL - An API for C and Fortran applications</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Grid Specification</a></li> 
      </ul>
    </div>
    <div class="container-wrapper">

      <div id="mobile-toggle">
        <a href="#"><span class="glyphicon glyphicon-align-justify" aria-hidden="true"></span></a>
      </div>
  <div id="left-column">
    <div class="sphinxsidebar">
<div class="sidebar-block">
  <div class="sidebar-wrapper">
    <div id="main-search">
      <form class="form-inline" action="../../search.html" method="GET" role="form">
        <div class="input-group">
          <input name="q" type="text" class="form-control" placeholder="Search...">
        </div>
        <input type="hidden" name="check_keywords" value="yes" />
        <input type="hidden" name="area" value="default" />
      </form>
    </div>
  </div>
</div>
      
    </div>
  </div>
        <div id="right-column">
          
          <div role="navigation" aria-label="breadcrumbs navigation">
            <ol class="breadcrumb">
              <li><a href="../../index.html">Docs</a></li>
              
                <li><a href="../../standard.html">Standard Specification</a></li>
              
                <li><a href="CGNS_MLL.html">CGNS/MLL - An API for C and Fortran applications</a></li>
              
              <li>Grid Specification</li>
            </ol>
          </div>
          
          <div class="document clearer body">
            
  <section id="grid-specification">
<span id="mllgridspecification"></span><h1>Grid Specification<a class="headerlink" href="#grid-specification" title="Permalink to this headline">Â¶</a></h1>
<!-- CGNS Mid-Level Library - Grid Specification -->

<html>
<head>
<meta http-equiv="Content-Style-Type" content="text/css">
<title> CGNS Mid-Level Library - Grid Specification </title>
</head>

<h2>Grid Specification</h2>

<ul>
<li> <a href="#gridcoordinates">Zone Grid Coordinates</a>
     <ul>
     <li> <tt><b>cg_grid_write</b></tt> - Create a <tt>GridCoordinates_t</tt> node
     <li> <tt><b>cg_ngrids</b></tt> - Get number of <tt>GridCoordinates_t</tt> nodes
     <li> <tt><b>cg_grid_read</b></tt> - Get name of a <tt>GridCoordinates_t</tt> node
     <li> <tt><b>cg_grid_bounding_box_read</b></tt> - Get bounding box associated to a <tt>GridCoordinates_t</tt> node
     <li> <tt><b>cg_grid_bounding_box_write</b></tt> - Write bounding box associated to a <tt>GridCoordinates_t</tt> node
     <li> <tt><b>cg_coord_write</b></tt> - Write grid coordinates
     <li> <tt><b>cg_coord_partial_write</b></tt> - Write subset of grid coordinates
     <li> <tt><b>cg_coord_general_write</b></tt> - Write shaped array to a subset of grid coordinates
     <li> <tt><b>cg_ncoords</b></tt> - Get number of coordinate arrays
     <li> <tt><b>cg_coord_info</b></tt> - Get info about a coordinate array
     <li> <tt><b>cg_coord_read</b></tt> - Read grid coordinates
     <li> <tt><b>cg_coord_general_read</b></tt> - Read subset of grid coordinates to a shaped array
     </ul>
<li> <a href="#elements">Element Connectivity</a>
     <ul>
     <li> <tt><b>cg_section_write</b></tt> - Write fixed size element data
     <li> <tt><b>cg_poly_section_write</b></tt> - Write element data
     <li> <tt><b>cg_section_general_write</b></tt> - Write section data without element data
     <li> <tt><b>cg_section_initialize</b></tt> - Initialize element data for not fixed size elements
     <li> <tt><b>cg_section_partial_write</b></tt> - Write subset of element data
     <li> <tt><b>cg_elements_partial_write</b></tt> - Write element data for a fixed size element section
     <li> <tt><b>cg_poly_elements_partial_write</b></tt> - Write element data for an element section
     <li> <tt><b>cg_elements_general_write</b></tt> - Write element data for a fixed size element section
     <li> <tt><b>cg_poly_elements_general_write</b></tt> - Write element data for an element section
     <li> <tt><b>cg_parent_data_write</b></tt> - Write parent info for an element section
     <li> <tt><b>cg_parent_data_partial_write</b></tt> - Write subset of parent info for an element section
     <li> <tt><b>cg_nsections</b></tt> - Get number of element sections
     <li> <tt><b>cg_section_read</b></tt> - Get info for an element section
     <li> <tt><b>cg_ElementDataSize</b></tt> - Get size of element connectivity data array
     <li> <tt><b>cg_ElementPartialSize</b></tt> - Get size of element connectivity data array for partial read
     <li> <tt><b>cg_elements_read</b></tt> - Read fixed size element data
     <li> <tt><b>cg_elements_partial_read</b></tt> - Read subset of fixed size element data
     <li> <tt><b>cg_elements_general_read</b></tt> - Read subset of fixed size element data to a typed array
     <li> <tt><b>cg_poly_elements_read</b></tt> - Read element data
     <li> <tt><b>cg_poly_elements_partial_read</b></tt> - Read subset of element data
     <li> <tt><b>cg_poly_elements_general_read</b></tt> - Read subset of element data to typed arrays
     <li> <tt><b>cg_parent_elements_general_read</b></tt> - Read parent info for an element section
     <li> <tt><b>cg_parent_elements_position_general_read</b></tt> - Read parent position info for an element section
     <li> <tt><b>cg_npe</b></tt> - Get number of nodes for an element type
     </ul>
<li> <a href="#axisymmetry">Axisymmetry</a>
     <ul>
     <li> <tt><b>cg_axisym_write</b></tt> - Create axisymmetry data
     <li> <tt><b>cg_axisym_read</b></tt> - Read axisymmetry data
     </ul>
<li> <a href="#rotatingcoordinates">Rotating Coordinates</a>
     <ul>
     <li> <tt><b>cg_rotating_write</b></tt> - Create rotating coordinates data
     <li> <tt><b>cg_rotating_read</b></tt> - Read rotating coordinates data
     </ul>
</ul>

<a name="gridcoordinates"></a>
<h3>Zone Grid Coordinates</h3>

<i>Node</i>: <tt>GridCoordinates_t</tt>
             (<a href="../sids/gridflow.html#GridCoordinates">SIDS</a>,
              <a href="../filemap/nodes.html#GridCoordinates">File Mapping</a>)

<p>
<tt>GridCoordinates_t</tt> nodes are used to describe grids associated
with a particular zone.
The original grid must be described by a <tt>GridCoordinates_t</tt> node
named <tt>GridCoordinates</tt>.
Additional <tt>GridCoordinates_t</tt> nodes may be used, with user-defined
names, to store grids at multiple time steps or iterations.
In addition to the discussion of the <tt>GridCoordinates_t</tt> node
in the <a href="../sids/gridflow.html#GridCoordinates">SIDS</a> and
<a href="../filemap/nodes.html#GridCoordinates">File Mapping</a> manuals,
see the discussion of the
<a href="../sids/timedep.html#ZoneIterativeData"><tt>ZoneIterativeData_t</tt></a>
and <a href="../sids/timedep.html#ArbitraryGridMotion"><tt>ArbitraryGridMotion_t</tt></a>
nodes in the SIDS manual.

<br><br>
<table width=100% cellspacing=0 cellpadding=5 border rules=groups
       bgcolor="#f5f5f0">
<colgroup width=90%>
<colgroup>
<thead>
<tr><th align=left scope=col width=90%>Functions
    <th scope=col>Modes
<tbody>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_grid_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>char *GridCoordName</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>int *G</i></span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_ngrids(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=out><i>int *ngrids</i></span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_grid_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int G</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>char *GridCoordName</i></span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_grid_bounding_box_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int G</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>DataType_t datatype</span>, <span class=in><i>void *bbox_array</i></span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_grid_bounding_box_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int G</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>DataType_t datatype</span>, <span class=out><i>void *bbox_array</i></span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tbody>
<tr><td nowrap>
        <tt><b>call cg_grid_write_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>GridCoordName</span>, <span class=out><i>G</i></span>, <span class=out><i>ier</i></span>)</b></tt>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b>call cg_ngrids_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=out><i>ngrids</i></span>, <span class=out><i>ier</i></span>)</b></tt>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b>call cg_grid_read_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>G</span>, <span class=out><i>GridCoordName</i></span>, <span class=out><i>ier</i></span>)</b></tt>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b>call <span class=cgf>cg_grid_bounding_box_write_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>G</span>, <span class=in>datatype</span>, <span class=in>bbox_array</span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b>call <span class=cgf>cg_grid_bounding_box_read_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>G</span>, <span class=in>datatype</span>, <span class=out>bbox_array</span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
</table>

<br>
<b><span class=in>Input</span>/<span class=out><i>Output</i></span></b>

<br><br>
<table cellspacing=0 cellpadding=0 noborder>
<tr valign=baseline><td><tt>&nbsp;&nbsp;&nbsp;</tt>
   <td><tt>fn</tt><td><tt>&nbsp;&nbsp;</tt>
   <td>CGNS file index number.
<tr valign=baseline><td>
   <td><tt>B</tt><td>
   <td>Base index number, where 1 &le; <tt>B</tt> &le; <tt>nbases</tt>.
<tr valign=baseline><td>
   <td><tt>Z</tt><td>
   <td>Zone index number, where 1 &le; <tt>Z</tt> &le; <tt>nzones</tt>.
<tr valign=baseline><td>
   <td><tt>G</tt><td>
   <td>Grid index number, where
       1 &le; <tt>G</tt> &le; <tt>ngrids</tt>.
<tr valign=baseline><td>
   <td><tt>ngrids</tt><td>
   <td>Number of <tt>GridCoordinates_t</tt> nodes for zone <tt>Z</tt>.
<tr valign=baseline><td>
   <td><tt>GridCoordinateName</tt><td>
   <td>Name of the <tt>GridCoordinates_t</tt> node.
       Note that the name "<tt>GridCoordinates</tt>" is reserved for the
       original grid and must be the first <tt>GridCoordinates_t</tt>
       node to be defined.
<tr valign=baseline><td>
   <td><tt>datatype</tt><td>
   <td>Data type of the bounding box array written to the file or read.
       Admissible data types for a coordinate bounding box are <tt>RealSingle</tt>
       and <tt>RealDouble</tt>.
<tr valign=baseline><td>
   <td><tt>bbox_array</tt><td>
   <td>Data Array with bounding box values.
<tr valign=baseline><td>
   <td><tt>ier</tt><td>
   <td>Error status.
</table>

<p>
The above functions are applicable to any <tt>GridCoordinates_t</tt> node.<br>
When reading a bounding box, if the information is missing from the file, the <tt>bbox_array</tt> will remain untouched, and a warning is emitted.<br>
The CGNS MLL relies on the user to compute the bounding box and ensure that the bounding box being stored is coherent with the coordinates under <tt>GridCoordinates_t</tt> node.


<a name="gridcoordinates_original"></a>
<br><br>
<table width=100% cellspacing=0 cellpadding=5 border rules=groups
       bgcolor="#f5f5f0">
<colgroup width=90%>
<colgroup>
<thead>
<tr><th align=left scope=col width=90%>Functions
    <th scope=col>Modes
<tbody>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_coord_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>DataType_t datatype</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>char *coordname</span>, <span class=in>void *coord_array</span>, <span class=out><i>int *C</i></span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_coord_partial_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>DataType_t datatype</span>, <span class=in>char *coordname</span>, <span class=in>cgsize_t *range_min</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t *range_max</span>, <span class=in>void *coord_array</span>, <span class=out><i>int *C</i></span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_coord_general_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>char *coordname</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>DataType_t datatype</span>, <span class=in>cgsize_t *range_min</span>, <span class=in>cgsize_t *range_max</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>DataType_t mem_datatype</span>, <span class=in>int mem_rank</span>, <span class=in>cgsize_t *mem_dimensions</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t *mem_range_min</span>, <span class=in>cgsize_t *mem_range_max</span>,</br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>void *coord_array</span>, <span class=out><i>int *C</i></span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_ncoords(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=out><i>int *ncoords</i></span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_coord_info(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int C</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>DataType_t *datatype</i></span>, <span class=out><i>char *coordname</i></span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_coord_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>char *coordname</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>DataType_t mem_datatype</span>, <span class=in>cgsize_t *range_min</span>, <span class=in>cgsize_t *range_max</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>void *coord_array</i></span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_coord_general_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>char *coordname</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t *range_min</span>, <span class=in>cgsize_t *range_max</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>DataType_t mem_datatype</span>, <span class=in>int mem_rank</span>, <span class=in>cgsize_t *mem_dimensions</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t *mem_range_min</span>, <span class=in>cgsize_t *mem_range_max</span>, <span class=out><i>void *coord_array</i></span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tbody>
<tr><td nowrap>
        <tt><b>call <span class=cgf>cg_coord_write_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>datatype</span>, <span class=in>coordname</span>, <span class=in>coord_array</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>C</i></span>, <span class=out><i>ier</i></span>)</b></tt>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b>call <span class=cgf>cg_coord_partial_write_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>datatype</span>, <span class=in>coordname</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>range_min</span>, <span class=in>range_max</span>, <span class=in>coord_array</span>, <span class=out><i>C</i></span>, <span class=out><i>ier</i></span>)</b></tt>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b>call <span class=cgf>cg_coord_general_write_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>coordname</span>, <span class=in>datatype</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>range_min</span>, <span class=in>range_max</span>, <span class=in>mem_datatype</span>, <span class=in>mem_rank</span>, <span class=in>mem_dimensions</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>mem_range_min</span>, <span class=in>mem_range_max</span>, <span class=in>coord_array</span>, <span class=out><i>C</i></span>, <span class=out><i>ier</i></span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b>call cg_ncoords_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=out><i>ncoords</i></span>, <span class=out><i>ier</i></span>)</b></tt>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b>call cg_coord_info_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>C</span>, <span class=out><i>datatype</i></span>, <span class=out><i>coordname</i></span>, <span class=out><i>ier</i></span>)</b></tt>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b>call <span class=cgf>cg_coord_read_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>coordname</span>, <span class=in>mem_datatype</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>range_min</span>, <span class=in>range_max</span>, <span class=out><i>coord_array</i></span>, <span class=out><i>ier</i></span>)</b></tt>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b>call <span class=cgf>cg_coord_general_read_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>coordname</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>range_min</span>, <span class=in>range_max</span>, <span class=in>mem_datatype</span>, <span class=in>mem_rank</span>, <span class=in>mem_dimensions</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>mem_range_min</span>, <span class=in>mem_range_max</span>, <span class=out><i>coord_array</i></span>, <span class=out><i>ier</i></span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
</table>

<br>
<b><span class=in>Input</span>/<span class=out><i>Output</i></span></b>


<br><br>
<table cellspacing=0 cellpadding=0 noborder>
<tr valign=baseline><td><tt>&nbsp;&nbsp;&nbsp;</tt>
   <td><tt>fn</tt><td><tt>&nbsp;&nbsp;</tt>
   <td>CGNS file index number.
<tr valign=baseline><td>
   <td><tt>B</tt><td>
   <td>Base index number, where 1 &le; <tt>B</tt> &le; <tt>nbases</tt>.
<tr valign=baseline><td>
   <td><tt>Z</tt><td>
   <td>Zone index number, where 1 &le; <tt>Z</tt> &le; <tt>nzones</tt>.
<tr valign=baseline><td>
   <td><tt>C</tt><td>
   <td>Coordinate array index number, where
       1 &le; <tt>C</tt> &le; <tt>ncoords</tt>.
<tr valign=baseline><td>
   <td><tt>ncoords</tt><td>
   <td>Number of coordinate arrays for zone <tt>Z</tt>.
<tr valign=baseline><td>
   <td><tt>datatype</tt><td>
   <td>Data type of the coordinate array written to the file.
       Admissible data types for a coordinate array are <tt>RealSingle</tt>
       and <tt>RealDouble</tt>.
<tr valign=baseline><td>
   <td><tt>coordname</tt><td>
   <td>Name of the coordinate array.
       It is strongly advised to use the
       <a href="../sids/dataname.html#dataname_grid">SIDS nomenclature
       conventions</a> when naming the coordinate arrays to insure file
       compatibility.
<tr valign=baseline><td>
   <td><tt>range_min</tt><td>
   <td>Lower range index in file (eg., <tt>imin, jmin, kmin</tt>).
<tr valign=baseline><td>
   <td><tt>range_max</tt><td>
   <td>Upper range index in file (eg., <tt>imax, jmax, kmax</tt>).
<tr valign=baseline><td>
   <td><tt>mem_datatype</tt><td>
   <td>Data type of an array in memory.
       Admissible data types for a coordinate array are <tt>RealSingle</tt>
       and <tt>RealDouble</tt>..
<tr valign=baseline><td>
   <td><tt>mem_rank</tt><td>
   <td>Number of dimensions of array in memory.
<tr valign=baseline><td>
   <td><tt>mem_dimensions</tt><td>
   <td>Dimensions of array in memory.
<tr valign=baseline><td>
   <td><tt>mem_range_min</tt><td>
   <td>Lower range index in memory (eg., <tt>imin, jmin, kmin</tt>).
<tr valign=baseline><td>
   <td><tt>mem_range_max</tt><td>
   <td>Upper range index in memory (eg., <tt>imax, jmax, kmax</tt>).
<tr valign=baseline><td>
   <td><tt>coord_array</tt><td>
   <td>Array of coordinate values.
<tr valign=baseline><td>
   <td><tt>ier</tt><td>
   <td>Error status.
</table>

<p>
The above functions are applicable <em>only</em> to the 
<tt>GridCoordinates_t</tt> node named <tt>GridCoordinates</tt>, used
for the original grid in a zone.
Coordinates for additional <tt>GridCoordinates_t</tt> nodes in a zone
must be read and written using the
<a href="physical.html#dataarray"><tt>cg_array_<i>xxx</i></tt> functions</a>.

<p>
When writing, the function <tt>cg_coord_write</tt> will
automatically write the full range of coordinates (i.e., the entire
<tt>coord_array</tt>).
The functions <tt>cg_coord_partial_write</tt> and <tt>cg_coord_general_write</tt> may be used to write
only a subset of <tt>coord_array</tt>.
When using the partial write, any existing data as defined by
<tt>range_min</tt> and <tt>range_max</tt> will be overwritten by the new
values.
All other values will not be affected.

<p>
The function <tt>cg_coord_read</tt> returns the coordinate array
<tt>coord_array</tt>, for the range prescribed by <tt>range_min</tt> and
<tt>range_max</tt>.
The array is returned to the application in the data type requested in
<tt>mem_datatype</tt>.
This data type does not need to be the same as the one in which the
coordinates are stored in the file.
A coordinate array stored as double precision in the CGNS file can be
returned to the application as single precision, or vice versa.
The functions <tt>cg_coord_general_read</tt> and <tt>cg_coord_general_write</tt>
allow for type conversion when both reading from and writing to the file.

<p>
In Fortran, when using <tt>cg_coord_read_f</tt> to read 2D or 3D
coordinates, the extent of each dimension of <tt>coord_array</tt> must
be consistent with the requested range.
When reading a 1D solution, the declared size can be larger than the
requested range.
For example, for a 2D zone with 100 &times; 50 vertices, if
<tt>range_min</tt> and <tt>range_max</tt> are set to (11,11) and (20,20)
to read a subset of the coordinates, then <tt>coord_array</tt> must be
dimensioned (10,10).
If <tt>coord_array</tt> is declared larger (e.g., (100,50)) the
indices for the returned coordinates will be wrong.
These restrictions can be avoided by using <tt>cg_coord_general_read_f</tt> instead.

<p>
When using <tt>cg_coord_general_write</tt> and
<tt>cg_coord_general_read</tt>, the lower <em>core</em> vertices in the file
have index 1 for defining <tt>range_min</tt> and <tt>range_max</tt>; whereas
for the array in memory, defined by <tt>mem_rank</tt> and
<tt>mem_dimensions</tt>, the lower <em>array</em> vertices in memory have
index 1 for defining <tt>mem_range_min</tt> and <tt>mem_range_max</tt>.
The actual lower and upper bounds of the array in memory can be anything.
For example, to fully read a two-dimensional 6 &times 6 coordinate array with 1
rind plane on each side in the file to an 8 &times 8 array in memory
(<tt>mem_rank</tt> = 2 and <tt>mem_dimensions</tt> = (8,8)), set
<tt>range_min</tt> and <tt>range_max</tt> to (0,0) and (7,7), and set
<tt>mem_range_min</tt> and <tt>mem_range_max</tt> to (1,1) and (8,8).

<a name="elements"></a>
<h3>Element Connectivity</h3>

<i>Node</i>: <tt>Elements_t</tt>
             (<a href="../sids/gridflow.html#Elements">SIDS</a>,
              <a href="../filemap/nodes.html#Elements">File Mapping</a>)

<br><br>
<table width=100% cellspacing=0 cellpadding=5 border rules=groups
       bgcolor="#f5f5f0">
<colgroup width=90%>
<colgroup>
<thead>
<tr><th align=left scope=col width=90%>Functions
    <th scope=col>Modes
<tbody>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_section_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>char *ElementSectionName</span>, <span class=in>ElementType_t type</span>, <span class=in>cgsize_t start</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t end</span>, <span class=in>int nbndry</span>, <span class=in>cgsize_t *Elements</span>, <span class=out><i>int *S</i></span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_poly_section_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>char *ElementSectionName</span>, <span class=in>ElementType_t type</span>, <span class=in>cgsize_t start</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t end</span>, <span class=in>int nbndry</span>, <span class=in>cgsize_t *Elements</span>, <span class=in>cgsize_t *ConnectOffset</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>int *S</i></span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_section_general_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>char *ElementSectionName</span>, <span class=in>ElementType_t type</span>, <span class=in>DataType_t ElementDataType</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t start</span>, <span class=in>cgsize_t end</span>, <span class=in>cgsize_t ElementDataSize</span>, <span class=in>int nbndry</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>int *S</i></span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_section_initialize(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_section_partial_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>char *ElementSectionName</span>, <span class=in>ElementType_t type</span>, <span class=in>cgsize_t start</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t end</span>, <span class=in>int nbndry</span>, <span class=out><i>int *S</i></span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_elements_partial_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="in">cgsize_t start</span>, <span class="in">cgsize_t end</span>, <span class="in">cgsize_t *Elements</span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_poly_elements_partial_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="in">cgsize_t start</span>, <span class="in">cgsize_t end</span>, <span class="in">cgsize_t *Elements</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t *ConnectOffset</span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_elements_general_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="in">cgsize_t start</span>, <span class="in">cgsize_t end</span>, <span class="in">DataType_t mem_datatype</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="in">void *Elements</span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_poly_elements_general_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="in">cgsize_t start</span>, <span class="in">cgsize_t end</span>, <span class="in">DataType_t mem_datatype</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="in">void *Elements</span>, <span class=in>void *ConnectOffset</span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_parent_data_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t *ParentData</span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_parent_data_partial_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t start</span>, <span class=in>cgsize_t end</span>, <span class=in>cgsize_t *ParentData</span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_nsections(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=out><i>int *nsections</i></span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_section_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>char *ElementSectionName</i></span>, <span class=out><i>ElementType_t *type</i></span>, <span class=out><i>cgsize_t *start</i></span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>cgsize_t *end</i></span>, <span class=out><i>int *nbndry</i></span>, <span class=out><i>int *parent_flag</i></span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_ElementDataSize(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>cgsize_t *ElementDataSize</i></span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_ElementPartialSize(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t start</span>, <span class=in>cgsize_t end</span>, <span class=out><i>cgsize_t *ElementDataSize</i></span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_elements_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>, <span class=out><i>cgsize_t *Elements</i></span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>cgsize_t *ParentData</i></span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_elements_partial_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t start</span>, <span class=in>cgsize_t end</span>, <span class=out><i>cgsize_t *Elements</i></span>, <span class=out><i>cgsize_t *ParentData</i></span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_elements_general_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t start</span>, <span class=in>cgsize_t end</span>, <span class=in>DataType_t mem_datatype</span>, <span class=out><i>void *Elements</i></span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_poly_elements_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>, <span class=out><i>cgsize_t *Elements</i></span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>cgsize_t *ConnectOffset</i></span>, <span class=out><i>cgsize_t *ParentData</i></span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_poly_elements_partial_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t start</span>, <span class=in>cgsize_t end</span>, <span class=out><i>cgsize_t *Elements</i></span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>cgsize_t *ConnectOffset</i></span>, <span class=out><i>cgsize_t *ParentData</i></span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_poly_elements_general_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t start</span>, <span class=in>cgsize_t end</span>, <span class=in>DataType_t *mem_datatype</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>void *Elements</i></span>, <span class=out><i>void *ConnectOffset</i></span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_parent_elements_general_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t start</span>, <span class=in>cgsize_t end</span>, <span class=in>DataType_t *mem_datatype</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>void *ParentElement</i></span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_parent_elements_position_general_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>int Z</span>, <span class=in>int S</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>cgsize_t start</span>, <span class=in>cgsize_t end</span>, <span class=in>DataType_t *mem_datatype</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>void *ParentFace</i></span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_npe(<span class=in>ElementType_t type</span>, <span class=out><i>int *npe</i></span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;w&nbsp;m</b></tt>
<tbody>
<tr><td nowrap>
        <tt><b>call <span class=cgf>cg_section_write_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>ElementSectionName</span>, <span class=in>type</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>start</span>, <span class=in>end</span>, <span class=in>nbndry</span>, <span class=in>Elements</span>, <span class=out><i>S</i></span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b>call <span class=cgf>cg_poly_section_write_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>ElementSectionName</span>, <span class=in>type</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>start</span>, <span class=in>end</span>, <span class=in>nbndry</span>, <span class=in>Elements</span>, <span class=in>ConnectOffset</span>, <span class=out><i>S</i></span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b>call <span class=cgf>cg_section_general_write_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>ElementSectionName</span>, <span class=in>type</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>ElementDataType</span>, <span class=in>start</span>, <span class=in>end</span>, <span class=in>ElementDataSize</span>, <span class=in>nbndry</span>, <span class=out><i>S</i></span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b>call <span class=cgf>cg_section_initialize_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>)</b><br>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b>call cg_section_partial_write_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>ElementSectionName</span>, <span class=in>type</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>start</span>, <span class=in>end</span>, <span class=in>nbndry</span>, <span class=out><i>S</i></span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b>call <span class=cgf>cg_elements_partial_write_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class="in">start</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>end</span>, <span class=in>Elements</span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b>call <span class=cgf>cg_poly_elements_partial_write_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class="in">start</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>end</span>, <span class=in>Elements</span>, <span class=in>ConnectOffset</span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b>call <span class=cgf>cg_elements_general_write_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class="in">start</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>end</span>, <span class=in>mem_datatype</span>, <span class=in>Elements</span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b>call <span class=cgf>cg_poly_elements_general_write_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class="in">start</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>end</span>, <span class=in>mem_datatype</span>, <span class=in>Elements</span>, <span class=in>ConnectOffset</span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b>call <span class=cgf>cg_parent_data_write_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=in>ParentData</span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b>call <span class=cgf>cg_parent_data_partial_write_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=in>start</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>end</span>, <span class=in>ParentData</span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b>call cg_nsections_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=out><i>nsections</i></span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b>call cg_section_read_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=out><i>ElementSectionName</i></span>, <span class=out><i>type</i></span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>start</i></span>, <span class=out><i>end</i></span>, <span class=out><i>nbndry</i></span>, <span class=out><i>parent_flag</i></span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b>call cg_ElementDataSize_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=out><i>ElementDataSize</i></span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b>call cg_ElementPartialSize_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=in>start</span>, <span class=in>end</span>, <span class=out><i>ElementDataSize</i></span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b>call <span class=cgf>cg_elements_read_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=out><i>Elements</i></span>, <span class=out><i>ParentData</i></span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b>call <span class=cgf>cg_elements_partial_read_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=in>start</span>, <span class=in>end</span>, <span class=out><i>Elements</i></span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>ParentData</i></span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b>call <span class=cgf>cg_poly_elements_read_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=out><i>Elements</i></span>, <span class=out><i>ConnectOffset</i></span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>ParentData</i></span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b>call <span class=cgf>cg_poly_elements_partial_read_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=in>start</span>, <span class=in>end</span>, <span class=out><i>Elements</i></span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>ConnectOffset</i></span>, <span class=out><i>ParentData</i></span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tr><td nowrap>
<tt><b>call <span class=cgf>cg_elements_general_read_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=in>start</span>, <span class=in>end</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>mem_datatype</span>, <span class=out><i>Elements</i></span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tr><td nowrap>
<tt><b>call <span class=cgf>cg_poly_elements_general_read_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=in>start</span>, <span class=in>end</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>mem_datatype</span>, <span class=out><i>Elements</i></span>, <span class=out><i>ConnectOffset</i></span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tr><td nowrap>
<tt><b>call <span class=cgf>cg_parent_elements_general_read_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=in>start</span>, <span class=in>end</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>mem_datatype</span>, <span class=out><i>ParentElement</i></span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tr><td nowrap>
<tt><b>call <span class=cgf>cg_parent_elements_position_general_read_f</span>(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>Z</span>, <span class=in>S</span>, <span class=in>start</span>, <span class=in>end</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>mem_datatype</span>, <span class=out><i>ParentFace</i></span>, <span class=out><i>ier</i></span>)</b><br>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b>call cg_npe_f(<span class=in>type</span>, <span class=out><i>npe</i></span>, <span class=out><i>ier</i></span>)</b></tt>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;w&nbsp;m</b></tt>
</table>

<br>
<b><span class=in>Input</span>/<span class=out><i>Output</i></span></b>


<br><br>
<table cellspacing=0 cellpadding=0 noborder>
<tr valign=baseline><td><tt>&nbsp;&nbsp;&nbsp;</tt>
   <td><tt>fn</tt><td><tt>&nbsp;&nbsp;</tt>
   <td>CGNS file index number.
<tr valign=baseline><td>
   <td><tt>B</tt><td>
   <td>Base index number, where 1 &le; <tt>B</tt> &le; <tt>nbases</tt>.
<tr valign=baseline><td>
   <td><tt>Z</tt><td>
   <td>Zone index number, where 1 &le; <tt>Z</tt> &le; <tt>nzones</tt>.
<tr valign=baseline><td>
   <td><tt>ElementSectionName</tt><td>
   <td>Name of the <tt>Elements_t</tt> node.
<tr valign=baseline><td>
   <td><tt>type</tt><td>
   <td>Type of element.
       See the eligible types for <tt>ElementType_t</tt> in the
       <a href="general.html#typedefs">Typedefs</a> section.
<tr valign=baseline><td>
   <td><tt>start</tt><td>
   <td>Index of first element in the section.
<tr valign=baseline><td>
   <td><tt>end</tt><td>
   <td>Index of last element in the section.
<tr valign=baseline><td>
   <td><tt>nbndry</tt><td>
   <td>Index of last boundary element in the section.
       Set to zero if the elements are unsorted.
<tr valign=baseline><td>
   <td><tt>nsections</tt><td>
   <td>Number of element sections.
<tr valign=baseline><td>
   <td><tt>S</tt><td>
   <td>Element section index, where
       1 &le; <tt>S</tt> &le; <tt>nsections</tt>.
<tr valign=baseline><td>
   <td><tt>parent_flag</tt><td>
   <td>Flag indicating if the parent data are defined.
       If the parent data exist, <tt>parent_flag</tt> is set to 1;
       otherwise it is set to 0.
<tr valign=baseline><td>
   <td><tt>ElementDataType</tt><td>
   <td>Data type of an array. Admissible data types are <tt>Integer</tt> and <tt>LongInteger</tt>.
<tr valign=baseline><td>
   <td><tt>ElementDataSize</tt><td>
   <td>Number of element connectivity data values.
<tr valign=baseline><td>
   <td><tt>Elements</tt><td>
   <td>Element connectivity data. The element connectivity order is given in
       <a href="../sids/conv.html#unstructgrid">Element Numbering Conventions</a>.
<tr valign=baseline><td>
   <td><tt>ConnectOffset</tt><td>
   <td>Element connectivity offset data. This is required for <tt>NGON_n</tt>, <tt>NFACE_n</tt> and <tt>MIXED</tt> according to
       <a href="../sids/gridflow.html#Elements">Elements_t Structure Definition</a>.
<tr valign=baseline><td>
   <td><tt>ParentData</tt><td>
   <td>For boundary or interface elements, this array contains
       information on the cell(s) and cell face(s) sharing the element.
       If you do not need to read the <tt>ParentData</tt> when reading
       the <tt>ElementData</tt>, you may set the value to <tt>NULL</tt>.
<tr valign=baseline><td>
   <td><tt>ParentElement</tt><td>
   <td>For boundary or interface elements, this array contains
       information on the cell(s) sharing the element.
<tr valign=baseline><td>
   <td><tt>ParentFace</tt><td>
   <td>For boundary or interface elements, this array contains
       information on the cell face(s) sharing the element.
<tr valign=baseline><td>
   <td><tt>mem_datatype</tt><td>
   <td>Data type of an array in memory. Admissible data types are <tt>Integer</tt> and <tt>LongInteger</tt>.
<tr valign=baseline><td>
   <td><tt>npe</tt><td>
   <td>Number of nodes for an element of type <tt>type</tt>.
<tr valign=baseline><td>
   <td><tt>ier</tt><td>
   <td>Error status.
</table>

<p>
It is important to note that each element under a given <tt>Zone_t</tt> - including
all cells, faces, edges, boundary elements, etc. - must have a unique element index 
number. The numbering should be consecutive (i.e., no gaps).
This global numbering system insures that each and every element 
within a zone is uniquely identified by its number.

<p>
If the specified <tt>Elements_t</tt> node doesn't yet exist, it may be
created using either <tt>cg_section_write</tt> or
<tt>cg_section_partial_write</tt>.
<tt>MIXED</tt>, <tt>NGON_n</tt>, and <tt>NFACE_n</tt> element sets
 may be created using <tt>cg_poly_section_write</tt> or <tt>cg_poly_section_partial_write</tt>.
The function <tt>cg_section_write</tt> writes the full range as
indicated by <tt>start</tt> and <tt>end</tt> and supplied by the element
connectivity array <tt>Elements</tt>.
The <tt>cg_section_partial_write</tt> function will create the element section
data for the range <tt>start</tt> to <tt>end</tt> with the element data
intialized to 0. <tt>cg_poly_section_write</tt> and <tt>cg_poly_section_partial_write</tt>
 have a comparable behavior for <tt>MIXED</tt>, <tt>NGON_n</tt>, and <tt>NFACE_n</tt>. 
To add elements to the section, use <tt>cg_elements_partial_write</tt>
or <tt>cg_poly_elements_partial_write</tt>
and parent data (it it exists) using <tt>cg_parent_data_partial_write</tt>.
These functions will replace the data for the range
as indicated by <tt>start</tt> and <tt>end</tt> with the new values.
In most cases, the data is not duplicated in the mid-level library and
written directly from the user data to disk.The exception to this is in the case
of <tt>MIXED</tt>, <tt>NGON_n</tt>, and <tt>NFACE_n</tt> element sets. Even if 
the size of the element connectivity array can be known through <tt>ConnectOffset</tt>, the MLL
will keep a copy of the data in memory for the partial writes.

<p>
The functions <tt>cg_elements_read</tt> and <tt>cg_poly_elements_read</tt> returns all of the element
connectivity and parent data.
Specified subsets of the element connectivity and parent data may be
read using <tt>cg_elements_partial_read</tt> or <tt>cg_poly_elements_partial_read</tt> (<tt>MIXED</tt>, <tt>NGON_n</tt>, <tt>NFACE_n</tt>).

<p>
<tt><b><font color="red">Note : cg_elements_read, cg_elements_partial_read, cg_section_write and cg_element_partial_write functions only work with fixed size elements.</font></b>

<a name="axisymmetry"></a>
<h3>Axisymmetry</h3>

<i>Node</i>: <tt>Axisymmetry_t</tt>
             (<a href="../sids/gridflow.html#Axisymmetry">SIDS</a>,
              <a href="../filemap/nodes.html#Axisymmetry">File Mapping</a>)

<br><br>
<table width=100% cellspacing=0 cellpadding=5 border rules=groups
       bgcolor="#f5f5f0">
<colgroup width=90%>
<colgroup>
<thead>
<tr><th align=left scope=col width=90%>Functions
    <th scope=col>Modes
<tbody>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_axisym_write(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=in>float *ReferencePoint</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>float *AxisVector</span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_axisym_read(<span class=in>int fn</span>, <span class=in>int B</span>, <span class=out><i>float *ReferencePoint</i></span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>float *AxisVector</i></span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tbody>
<tr><td nowrap>
        <tt><b>call cg_axisym_write_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=in>ReferencePoint</span>, <span class=in>AxisVector</span>, <span class=out><i>ier</i></span>)</b></tt>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b>call cg_axisym_read_f(<span class=in>fn</span>, <span class=in>B</span>, <span class=out><i>ReferencePoint</i></span>, <span class=out><i>AxisVector</i></span>, <span class=out><i>ier</i></span>)</b></tt>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
</table>

<br>
<b><span class=in>Input</span>/<span class=out><i>Output</i></span></b>


<br><br>
<table cellspacing=0 cellpadding=0 noborder>
<tr valign=baseline><td><tt>&nbsp;&nbsp;&nbsp;</tt>
   <td><tt>fn</tt><td><tt>&nbsp;&nbsp;</tt>
   <td>CGNS file index number.
<tr valign=baseline><td>
   <td><tt>B</tt><td>
   <td>Base index number, where 1 &le; <tt>B</tt> &le; <tt>nbases</tt>.
<tr valign=baseline><td>
   <td><tt>ReferencePoint</tt><td>
   <td>Origin used for defining the axis of rotation.
       (In Fortran, this is an array of Real*4 values.)
<tr valign=baseline><td>
   <td><tt>AxisVector</tt><td>
   <td>Direction cosines of the axis of rotation, through the reference
       point.
       (In Fortran, this is an array of Real*4 values.)
<tr valign=baseline><td>
   <td><tt>ier</tt><td>
   <td>Error status.
</table>

<p>
This node can only be used for a bi-dimensional model, i.e.,
<tt>PhysicalDimension</tt> must equal two.

<a name="rotatingcoordinates"></a>
<h3>Rotating Coordinates</h3>

<i>Node</i>: <tt>RotatingCoordinates_t</tt>
             (<a href="../sids/gridflow.html#RotatingCoordinates">SIDS</a>,
              <a href="../filemap/nodes.html#RotatingCoordinates">File Mapping</a>)

<br><br>
<table width=100% cellspacing=0 cellpadding=5 border rules=groups
       bgcolor="#f5f5f0">
<colgroup width=90%>
<colgroup>
<thead>
<tr><th align=left scope=col width=90%>Functions
    <th scope=col>Modes
<tbody>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_rotating_write(<span class=in>float *RotationRateVector</span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=in>float *RotationCenter</span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b><span class=out><i>ier</i></span> = cg_rotating_read(<span class=out><i>float *RotationRateVector</i></span>,<br>
               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=out><i>float *RotationCenter</i></span>);</b></tt>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
<tbody>
<tr><td nowrap>
        <tt><b>call cg_rotating_write_f(<span class=in>RotationRateVector</span>, <span class=in>RotationCenter</span>, <span class=out><i>ier</i></span>)</b></tt>
    <td align=center valign=baseline>
        <tt><b>-&nbsp;w&nbsp;m</b></tt>
<tr><td nowrap>
        <tt><b>call cg_rotating_read_f(<span class=out><i>RotationRateVector</i></span>, <span class=out><i>RotationCenter</i></span>, <span class=out><i>ier</i></span>)</b></tt>
    <td align=center valign=baseline>
        <tt><b>r&nbsp;-&nbsp;m</b></tt>
</table>

<br>
<b><span class=in>Input</span>/<span class=out><i>Output</i></span></b>


<br><br>
<table cellspacing=0 cellpadding=0 noborder>
<tr valign=baseline><td><tt>&nbsp;&nbsp;&nbsp;</tt>
   <td><tt>RotationRateVector</tt><td><tt>&nbsp;&nbsp;</tt>
   <td>Components of the angular velocity of the grid about the center
       of rotation.
       (In Fortran, this is an array of Real*4 values.)
<tr valign=baseline><td>
   <td><tt>RotationCenter</tt><td>
   <td>Coordinates of the center of rotation.
       (In Fortran, this is an array of Real*4 values.)
<tr valign=baseline><td>
   <td><tt>ier</tt><td>
   <td>Error status.
</table>

<p>
</body>
</html>
</section>


          </div>
            
  <div class="footer-relations">
    
      <div class="pull-left">
        <a class="btn btn-default" href="CGNS_MLL_auxiliary.html" title="previous chapter (use the left arrow)">Auxiliary Data</a>
      </div>
    
      <div class="pull-right">
        <a class="btn btn-default" href="CGNS_MLL_solution.html" title="next chapter (use the right arrow)">Solution Data</a>
      </div>
    </div>
    <div class="clearer"></div>
  
        </div>
        <div class="clearfix"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="CGNS_MLL_solution.html" title="Solution Data"
             >next</a> |</li>
        <li class="right" >
          <a href="CGNS_MLL_auxiliary.html" title="Auxiliary Data"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">CGNS Official Web Site</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../standard.html" >Standard Specification</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="CGNS_MLL.html" >CGNS/MLL - An API for C and Fortran applications</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Grid Specification</a></li> 
      </ul>
    </div>
<script type="text/javascript">
  $("#mobile-toggle a").click(function () {
    $("#left-column").toggle();
  });
</script>
<script type="text/javascript" src="../../_static/js/bootstrap.js"></script>
  <div class="footer">
    &copy; Copyright 1991-2020, CGNS Steering Commmittee. Created using <a href="http://sphinx.pocoo.org/">Sphinx</a>.
  </div>
  </body>
</html>